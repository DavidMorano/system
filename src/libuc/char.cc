/* char SUPPORT */
/* encoding=ISO8859-1 */
/* lang=C++20 */

/* character test and conversion support */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-04-05, David A­D­ Morano
	This module was adapted from assembly langauge.

	= 2014-08-19, David A­D­ Morano
	I changed this to use the C++ |bitset| object instead of
	an array of bytes for the single-bit truth-value observers.
	This was not really necessary since an array of |char|s
	treated as an array of bits was completely fine and worked
	just fine (essentially identical to the use of |bitset(3c++)|).

	= 2023-04-08, David A­D­ Morano
	I am taking advantage of the C++23 constant-expresssion
	enhancement |bitset(3c++)| to make the lookup tables
	constant-expression capable.

*/

/* Copyright © 1998,2014,2023 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Group:
	char

	Description:
	This module provides some character conversion tables for
	use in either the 'C' locale or when using the ISO-Latin-1
	character set (locale 'en_US.ISO8859-1').  These tables are
	provided for fast conversions when the locale is not necessary
	to be changable.  Only 8-bit characters are supported
	(ISO-Latin-1 character set).  For other character sets, use
	the system-supplied facilities.

	Notes: 
	1. Note that non-breaking-white-space (NBSP) characters are
	*not* considered to be white-space!
	2. The data tables below that convert characters to a certain
	"case" (upper, lower, and fold) are created by a supporting
	program (forget is name right now).  The table below that
	converts to a dictionary order is also created by an external
	program.  Someday, those tables should be created at module
	load-time.

*******************************************************************************/

#include	<envstandards.h>	/* MUST be first to configure */
#include	<climits>		/* |UCHAR_MAX| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<bitset>		/* <- the money shot! */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<localmisc.h>		/* |UC(3misc)| */

#include	"char.h"


/* local defines */


/* imported namespaces */

using std::bitset ;			/* type */


/* local typedefs */


/* external subroutines */


/* external variables */


/* local structures */

namespace {
    constexpr int   chtablen = (UCHAR_MAX + 1) ;
    struct charinfo {
	bitset<chtablen>	iswhite ;
	bitset<chtablen>	islc ;
	bitset<chtablen>	isuc ;
	uchar			toval[chtablen] ;
	constexpr void mkiswhite() noex ;
	constexpr void mkislc() noex ;
	constexpr void mkisuc() noex ;
	constexpr void mktoval() noex ;
	constexpr charinfo() noex {
	    mkiswhite() ;
	    mkislc() ;
	    mkisuc() ;
	    mktoval() ;
	} ;
    } ; /* end struct (charinfo) */
} /* end namespace */

constexpr void charinfo::mkiswhite() noex {
	constexpr char	w[] = " \t\f\v\r" ;
	for (int i = 0 ; w[i] ; i += 1) {
	    cint	ch = w[i] ;
	    iswhite.set(ch,true) ;
	}
}
/* end method (charinfo::mkiswhite) */

constexpr void charinfo::mkislc() noex {
	for (int ch = 'a' ; ch <= 'z' ; ch += 1) {
	    islc.set(ch,true) ;
	}
	for (int ch = UC('à') ; ch <= UC('ÿ') ; ch += 1) {
	    islc.set(ch,true) ;
	}
	islc.set(UC('÷'),false) ;
	islc.set(UC('ß'),true) ; 	/* <- this is 'ss' in German */
}
/* end method (charinfo::mkislc) */

constexpr void charinfo::mkisuc() noex {
	for (int ch = 'A' ; ch <= 'Z' ; ch += 1) {
	    isuc.set(ch,true) ;
	}
	for (int ch = UC('À') ; ch <= UC('Þ') ; ch += 1) {
	    isuc.set(ch,true) ;
	}
	isuc.set(UC('×'),false) ;
	isuc.set(UC('ß'),false) ; 	/* <- this is 'ss' in German */
}
/* end method (charinfo::mkisuc) */

constexpr void charinfo::mktoval() noex {
        for (int ch = 0 ; ch < chtablen ; ch += 1) {
            if ((ch >= '0') && (ch <= '9')) {
                toval[ch] = uchar(ch - '0') ;
            } else if ((ch >= 'A') && (ch <= 'Z')) {
                toval[ch] = uchar((ch - 'A') + 10) ;
            } else if ((ch >= 'a') && (ch <= 'z')) {
                toval[ch] = uchar((ch - 'a') + 36) ;
            } else if (ch == UC('Ø')) {
                toval[ch] = 62 ;
            } else if (ch == UC('ø')) {
                toval[ch] = 63 ;
            } else {
                toval[ch] = UCHAR_MAX ;
            }
        } /* end for */
}
/* end method (charinfo::mktoval) */


/* local variables */

constexpr charinfo	char_data ;


/* exported variables */

/* convert characters to lower case */
const unsigned char chardata_tolc[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
	0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
	0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
	0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
	0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
	0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xd7,
	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xdf,
	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
	0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
	0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
} ; /* end array (chardata_tolc) */

/* convert characters to upper case */
const unsigned char chardata_touc[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
	0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
	0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
	0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
	0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
	0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
	0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
	0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xf7,
	0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xff
} ; /* end array (chardata_touc) */

/* convert characters to folded case */
const unsigned char chardata_tofc[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
	0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
	0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
	0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
	0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xc6, 0x43,
	0x45, 0x45, 0x45, 0x45, 0x49, 0x49, 0x49, 0x49,
	0xd0, 0x4e, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0xd7,
	0xd8, 0x55, 0x55, 0x55, 0x55, 0x59, 0xde, 0xdf,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0xc6, 0x43,
	0x45, 0x45, 0x45, 0x45, 0x49, 0x49, 0x49, 0x49,
	0xd0, 0x4e, 0x4f, 0x4f, 0x4f, 0x4f, 0x4f, 0xf7,
	0xd8, 0x55, 0x55, 0x55, 0x55, 0x59, 0xde, 0x59
} ; /* end array (chardata_tofc) */

/* dictionary-collating-ordinal */
const short	chardata_dictorder[] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x006a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0066,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0065, 0x0000, 0x0000,
	0x03e8, 0x03e9, 0x03ea, 0x03eb, 0x03ec, 0x03ed, 0x03ee, 0x03ef,
	0x03f0, 0x03f1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x03f2, 0x0402, 0x0404, 0x0408, 0x040a, 0x0414, 0x0416,
	0x0418, 0x041a, 0x0424, 0x0426, 0x0428, 0x042a, 0x042e, 0x0432,
	0x0440, 0x0442, 0x0444, 0x0446, 0x0448, 0x044a, 0x0454, 0x0456,
	0x0458, 0x045a, 0x045f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0067, 0x03f9, 0x0403, 0x0406, 0x0409, 0x040f, 0x0415, 0x0417,
	0x0419, 0x041f, 0x0425, 0x0427, 0x0429, 0x042b, 0x0430, 0x0438,
	0x0441, 0x0443, 0x0445, 0x0447, 0x0449, 0x044f, 0x0455, 0x0457,
	0x0459, 0x045c, 0x0460, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0069, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0064, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0068, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x03f4, 0x03f3, 0x03f5, 0x03f8, 0x03f7, 0x03f6, 0x0400, 0x0405,
	0x040c, 0x040b, 0x040d, 0x040e, 0x041c, 0x041b, 0x041d, 0x041e,
	0x042c, 0x042f, 0x0434, 0x0433, 0x0435, 0x0437, 0x0436, 0x0000,
	0x043e, 0x044c, 0x044b, 0x044d, 0x044e, 0x045b, 0x0461, 0x0463,
	0x03fb, 0x03fa, 0x03fc, 0x03ff, 0x03fe, 0x03fd, 0x0401, 0x0407,
	0x0411, 0x0410, 0x0412, 0x0413, 0x0421, 0x0420, 0x0422, 0x0423,
	0x042d, 0x0431, 0x043a, 0x0439, 0x043b, 0x043d, 0x043c, 0x0000,
	0x043f, 0x0451, 0x0450, 0x0452, 0x0453, 0x045d, 0x0462, 0x045e
} ; /* end array (chardata_dictorder) */


/* exported variables */


/* exported subroutines */

bool char_iswhite(int ch) noex {
	return char_data.iswhite[ch & UCHAR_MAX] ;
}

bool char_islc(int ch) noex {
	return char_data.islc[ch & UCHAR_MAX] ;
}

bool char_isuc(int ch) noex {
	return char_data.isuc[ch & UCHAR_MAX] ;
}

int char_toval(int ch) noex {
	return char_data.toval[ch & UCHAR_MAX] ;
}


/* local subroutines */


