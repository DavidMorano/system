/* vecpstr SUPPORT */
/* encoding=ISO8859-1 */
/* lang=C++20 */

/* vector-packed-string object */
/* version %I% last-modified %G% */

#define	CF_QSORT	0		/* use |qsort(3c)| */

/* revision history:

	= 1998-03-24, David A­D­ Morano
        This object module was morphed from some previous one. I do not remember
        what the previous one was.

*/

/* Copyright © 1998 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Name:
	vecpstr

	Description:
	This object module creates and manages a string table object.
	This string table can later be written to a file or otherwise
	stored some way so that it can be used in-place later.  This
	is often useful for cache files or ELF code object files.

	Arguments:
	stp		pointer to the vecpstr object
	<others>

	Returns:
	>=0		the total length of the filled up vecpstr so far!
	<0		error


	Notes:
	The index table (optionally) generated by this OBJECT using
	-> hash-linking <- to track down matches.  It does not use
	-> key-linking <-.  So searching the generated index table
	must also use hash-linking.


	Name:
	vecpstr_adduniq

	Description:
	This subroutine adds a string to the object, but first
	checks to see if it is already present.  Specified strings
	that already match an existing entry are not added.

	Synopsis:
	int vecpstr_adduniq(vecpstr *op,cchar *sp,int sl) noex

	Arguments:
	op		vecpstr string to add to
	sp		pointer to key string to add
	sl		length of string to add

	Returns:
	INT_MAX		string was already in container
	>=0		OK
	<0		error

*******************************************************************************/

#include	<envstandards.h>	/* ordered first to configure */
#include	<unistd.h>
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<cstring>		/* |strlen(3c)| */
#include	<new>
#include	<algorithm>
#include	<usystem.h>
#include	<vechand.h>
#include	<vstrcmpx.h>
#include	<nleadstr.h>
#include	<strwcpy.h>
#include	<intceil.h>
#include	<nextpowtwo.h>
#include	<localmisc.h>

#include	"vecpstr.h"


/* local defines */

#define	VECPSTR_CHSIZEIZE	512	/* starting table size */
#define	VECPSTR_NSKIP		5

#define	MODP2(v,n)	((v) & ((n) - 1))


/* imported namespaces */

using std::nullptr_t ;			/* type */
using std::sort ;			/* subroutine-template */
using std::min ;			/* subroutine-template */
using std::nothrow ;			/* constant */


/* local typedefs */

typedef vecpstr_ch	chunk ;

extern "C" {
    typedef int (*qsort_f)(cvoid *,cvoid *) noex ;
}


/* external subroutines */


/* local structures */

struct strentry {
	uint	khash ;
	uint	hi ;
	uint	si ;
} ;


/* forward references */

static int	vecpstr_ctor(vecpstr *) noex ;
static int	vecpstr_dtor(vecpstr *) noex ;
static int	vecpstr_setopts(vecpstr *,int) noex ;
static int	vecpstr_insertsp(vecpstr *,int,cchar *) noex ;
static int	vecpstr_finchunks(vecpstr *) noex ;
static int	vecpstr_extstr(vecpstr *,int) noex ;
static int	vecpstr_newchunk(vecpstr *,int) noex ;
static int	vecpstr_extvec(vecpstr *,int = 0) noex ;
static int	vecpstr_record(vecpstr *,cchar *) noex ;
static int	vecpstr_reset(vecpstr *) noex ;
static int	vecpstr_validx(vecpstr *,int) noex ;
static void	vecpstr_arrsort(vecpstr *,vecpstr_vcmp) noex ;

template<typename ... Args>
static inline int vecpstr_magic(vecpstr *op,Args ... args) noex {
	int		rs = SR_FAULT ;
	if (op && (args && ...)) {
	    rs = (op->magic == VECPSTR_MAGIC) ? SR_OK : SR_NOTOPEN ;
	}
	return rs ;
}

static int chunk_start(vecpstr_ch *,int) noex ;
static int chunk_finish(vecpstr_ch *) noex ;
static int chunk_check(vecpstr_ch *,int) noex ;
static int chunk_add(vecpstr_ch *,cchar *,int,cchar **) noex ;
static int chunk_addkeyval(vecpstr_ch *,cchar *,int,cchar *,int,cchar **) noex ;

static int	indexlen(int) noex ;
static int	indexsize(int) noex ;


/* local subroutines */

consteval int mkoptmask() noex {
	int		m = 0 ;
	m |= VECPSTR_ODEFAULT ;
	m |= VECPSTR_OREUSE ;
	m |= VECPSTR_OCOMPACT ;
	m |= VECPSTR_OSWAP ;
	m |= VECPSTR_OSTATIONARY ;
	m |= VECPSTR_OCONSERVE ;
	m |= VECPSTR_OSORTED ;
	m |= VECPSTR_OORDERED ;
	return m ;
}
/* end subroutine (mkoptmask) */


/* local variables */

constexpr bool		f_qsort = CF_QSORT ;

constexpr int		optmask = mkoptmask() ;

constexpr int		resz = szof(int) ;


/* exported variables */


/* exported subroutines */

int vecpstr_start(vecpstr *op,int vn,int vsz,int vo) noex {
	int		rs ;
	if ((rs = vecpstr_ctor(op)) >= 0) {
	    if (vsz < VECPSTR_CHSIZEIZE) vsz = VECPSTR_CHSIZEIZE ;
	    if (vn < 0) vn = 0 ;
	    op->chsize = vsz ;
	    op->an = vn ;
	    if ((rs = vecpstr_setopts(op,vo)) >= 0) {
	        cint	nc = min(((vn * 6) / vsz),1) ;
	        if ((rs = vechand_start(op->clp,nc,0)) >= 0) {
	            op->magic = VECPSTR_MAGIC ;
	        }
	    }
	    if (rs < 0) {
		vecpstr_dtor(op) ;
	    }
	} /* end if (non-null) */
	return rs ;
}
/* end subroutine (vecpstr_start) */

int vecpstr_finish(vecpstr *op) noex {
	int		rs ;
	int		rs1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if (op->va) {
	        rs1 = uc_libfree(op->va) ;
	        if (rs >= 0) rs = rs1 ;
	        op->va = nullptr ;
	    }
	    {
	        rs1 = vecpstr_finchunks(op) ;
	        if (rs >= 0) rs = rs1 ;
	    }
	    {
	        rs1 = vechand_finish(op->clp) ;
	        if (rs >= 0) rs = rs1 ;
	    }
	    {
		rs1 = vecpstr_dtor(op) ;
		if (rs >= 0) rs = rs1 ;
	    }
	    op->magic = 0 ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_finish) */

int vecpstr_audit(vecpstr *op) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
		for (int i = 0 ; i < op->i ; i += 1) {
	    	    if (op->va[i] != nullptr) {
			cchar	*cp = op->va[i] ;
			c += 1 ;
			{
			    const uintptr_t vv = uintptr_t(cp) ;
			    {
				cint	v = int(vv & INT_MAX) ;
	        	        rs |= v ;	/* access might SEGFAULT */
			    }
			}
	    	    } /* end if (non-empty entry) */
		} /* end for */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_audit) */

int vecpstr_add(vecpstr *op,cchar *sp,int sl) noex {
	return vecpstr_store(op,sp,sl,nullptr) ;
}
/* end subroutine (vecpstr_add) */

int vecpstr_adduniq(vecpstr *op,cchar *sp,int sl) noex {
	int		rs = SR_FAULT ;
	if (op && sp) {
	    if (sl < 0) sl = strlen(sp) ;
	    if ((rs = vecpstr_findn(op,sp,sl)) >= 0) {
	        rs = INT_MAX ;
	    } else if (rs == SR_NOTFOUND) {
	        rs = vecpstr_add(op,sp,sl) ;
	    }
	} /* end if (non-null) */
	return rs ;
}
/* end subroutine (vecpstr_adduniq) */

int vecpstr_addkeyval(vecpstr *op,cchar *kp,int kl,cchar *vp,int vl) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,kp)) >= 0) {
		int	amount = 0 ;
	        if (kl < 0) kl = strlen(kp) ;
	        amount += (kl+1) ;
	        if (vp) {
	            if (vl < 0) vl = strlen(vp) ;
	            amount += (vl+1) ;
	        }
	        if ((rs = vecpstr_extstr(op,amount)) >= 0) {
	            cchar	*cp{} ;
	            if ((rs = chunk_addkeyval(op->chp,kp,kl,vp,vl,&cp)) >= 0) {
	                if ((rs = vecpstr_record(op,cp)) >= 0) {
	                    i = rs ;
	        	    op->stsize += amount ;
			}
	            }
	        }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_addkeyval) */

int vecpstr_insert(vecpstr *op,int ii,cchar *sp,int sl) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_validx(op,ii)) >= 0) {
	    if (sl < 0) sl = strlen(sp) ;
	    if ((op->i + 1) > op->n) {
	        rs = vecpstr_extvec(op) ;
	    }
	    if (rs >= 0) {
	        cint	sz = (sl+1) ;
	        if (char *bp ; (rs = uc_libmalloc(sz,&bp)) >= 0) {
	            strwcpy(bp,sp,sl) ;
	            op->stsize += sz ;
	            i = vecpstr_insertsp(op,ii,bp) ;
	        } /* end if (memory-allocation) */
	    } /* end if (OK) */
	} /* end if (valid index) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_insert) */

int vecpstr_store(vecpstr *op,cchar *sp,int sl,cchar **rpp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
	    if (sl < 0) sl = strlen(sp) ;
	    {
	        cint	amount = (sl + 1) ;
	        cchar	*cp = nullptr ;
	        if ((rs = vecpstr_extstr(op,amount)) >= 0) {
	            if ((rs = chunk_add(op->chp,sp,sl,&cp)) >= 0) {
	                if ((rs = vecpstr_record(op,cp)) >= 0) {
	                     i = rs ;
	                     op->stsize += amount ;
			}
	            }
	        }
	        if (rpp) {
	            *rpp = (rs >= 0) ? cp : nullptr ;
	        }
	    } /* end block */
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_store) */

int vecpstr_already(vecpstr *op,cchar *sp,int sl) noex {
	return vecpstr_findn(op,sp,sl) ;
}
/* end subroutine (vecpstr_already) */

int vecpstr_get(vecpstr *op,int i,cchar **rpp) noex {
	int		rs ;
	if ((rs = vecpstr_validx(op,i)) >= 0) {
	    if (rpp) {
	        *rpp = (rs >= 0) ? op->va[i] : nullptr ;
	    }
	} /* end if (validx) */
	return rs ;
}
/* end subroutine (vecpstr_get) */

int vecpstr_getlast(vecpstr *op,cchar **spp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    rs = SR_NOTFOUND ;
	    if (op->va && (op->c > 0)) {
	        i = (op->i-1) ;
	        while ((i >= 0) && (op->va[i] == nullptr)) {
		    i -= 1 ;
	        }
	        if (i >= 0) rs = SR_OK ;
	    } /* end if (populated) */
	    if (spp) {
	        *spp = (rs >= 0) ? op->va[i] : nullptr ;
	    }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_getlast) */

int vecpstr_del(vecpstr *op,int i) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_validx(op,i)) >= 0) {
            bool        f_fi = false ;
            if (op->va[i] != nullptr) {
                op->c -= 1 ;            /* decrement list count */
                if (op->f.stsize) {
                    op->stsize -= (strlen(op->va[i]) + 1) ;
                }
            } /* end if (freeing the actual string data) */
            if (op->f.ostationary) {
                op->va[i] = nullptr ;
                if (i == (op->i - 1)) op->i -= 1 ;
                f_fi = true ;
            } else if (op->f.issorted || op->f.oordered) {
                if (op->f.ocompact) {
                    op->i -= 1 ;
                    for (int j = i ; j < op->i ; j += 1) {
                        op->va[j] = op->va[j + 1] ;
                    }
                    op->va[op->i] = nullptr ;
                } else {
                    op->va[i] = nullptr ;
                    if (i == (op->i - 1)) op->i -= 1 ;
                    f_fi = true ;
                } /* end if */
            } else {
                bool    f = (op->f.oswap || op->f.ocompact) ;
                if (f && (i < (op->i - 1))) {
                    op->va[i] = op->va[op->i - 1] ;
                    op->va[--op->i] = nullptr ;
                    op->f.issorted = false ;
                } else {
                    op->va[i] = nullptr ;
                    if (i == (op->i - 1)) op->i -= 1 ;
                    f_fi = true ;
                } /* end if */
            } /* end if */
            if (op->f.oconserve) {
                while (op->i > i) {
                    if (op->va[op->i - 1] != nullptr) break ;
                    op->i -= 1 ;
                } /* end while */
            } /* end if */
            if (f_fi && (i < op->fi)) {
                op->fi = i ;
            }
            c = op->c ;
            op->f.stsize = false ;
	} else if (rs == SR_NOTFOUND) {
	    rs = vecpstr_delall(op) ;
	} /* end if (validx) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_del) */

int vecpstr_delall(vecpstr *op) noex {
	int		rs ;
	int		rs1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    {
	        rs1 = vecpstr_finchunks(op) ;
	        if (rs >= 0) rs = rs1 ;
	        op->chp = nullptr ;
	    }
	    {
	        rs1 = vechand_delall(op->clp) ;
	        if (rs >= 0) rs = rs1 ;
	    }
	    if (op->va) {
	        rs1 = uc_libfree(op->va) ;
	        if (rs >= 0) rs = rs1 ;
	        op->va = nullptr ;
	    }
	    if (rs >= 0) {
	        rs = vecpstr_reset(op) ;
	    }
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_delall) */

int vecpstr_count(vecpstr *op) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op)) >= 0) {
		rs = op->c ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_count) */

int vecpstr_sort(vecpstr *op,vecpstr_vcmp vcf) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	        if (op->va) {
		    rs = SR_OK ;
		    if (vcf == nullptr) vcf = vstrcmp ;
	            if ((! op->f.issorted) && (op->i > 1)) {
		        vecpstr_arrsort(op,vcf) ;
	            } /* end if (sorting) */
	            op->f.issorted = true ;
		} /* end if (populated) */
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_sort) */

int vecpstr_search(vecpstr *op,cchar *sp,vecpstr_vcmp vcf,cchar **rpp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
		rs = SR_NOTFOUND ;
	        if (op->va) {
		    cchar	**rpp2 ;
		    if (vcf == nullptr) vcf = vstrcmp ;
	            if (op->f.issorted) {
	                cint	esize = szof(char *) ;
	                qsort_f	scf = qsort_f(vcf) ;
	                rpp2 = (cchar **) bsearch(&sp,op->va,op->i,esize,scf) ;
	                rs = SR_NOTFOUND ;
	                if (rpp2) {
	                    i = (rpp2 - op->va) ;
	                    rs = SR_OK ;
	                }
	            } else {
	                for (i = 0 ; i < op->i ; i += 1) {
	                    rpp2 = (op->va + i) ;
	                    if (*rpp2) {
	                        if ((*vcf)(&sp,rpp2) == 0) break ;
		            }
	                } /* end for */
	                rs = (i < op->i) ? SR_OK : SR_NOTFOUND ;
	            } /* end if (sorted or not) */
		} /* end if (was populated) */
	        if (rpp) {
	            *rpp = (rs >= 0) ? op->va[i] : nullptr ;
	        }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_search) */

int vecpstr_finder(vecpstr *op,cchar *sp,vecpstr_vcmp vcf,cchar **rpp) noex {
	int		rs = SR_FAULT ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
		rs = SR_NOTFOUND ;
	        if (op->va) {
		   int		i = 0 ; /* <- used afterwards */
	           if (vcf == nullptr) vcf = vstrcmp ;
	           for (i = 0 ; i < op->i ; i += 1) {
	                if (op->va[i]) {
	                   if ((*vcf)(&sp,(op->va+i)) == 0) break ;
	                }
	           } /* end for */
	           if (i < op->i) rs = i ;
	           if (rpp) {
	               *rpp = (rs >= 0) ? op->va[i] : nullptr ;
	           }
		} /* end if (populated) */
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_finder) */

int vecpstr_find(vecpstr *op,cchar *sp) noex {
        int             rs ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
                rs = SR_NOTFOUND ;
                if (op->va) {
                    cint        sch = sp[0] ; /* ok: all promoted similarly */
                    int         i ;
                    for (i = 0 ; i < op->i ; i += 1) {
                        cchar   *ep = op->va[i] ;
                        if (ep) {
                            if ((sch == ep[0]) && (strcmp(sp,ep) == 0)) break ;
                        }
                    } /* end for */
                    if (i < op->i) rs = i ;
                } /* end if (populated) */
	} /* end if (magic) */
        return rs ;
}
/* end subroutine (vecpstr_find) */

int vecpstr_findn(vecpstr *op,cchar *sp,int sl) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
	    int		sch = sp[0] ; /* ok: since all get promoted similarly */
	    int		i{} ;		/* <- used afterwards */
	    rs = SR_NOTFOUND ;
	    if (sl < 0) sl = strlen(sp) ;
	    for (i = 0 ; i < op->i ; i += 1) {
	        cchar	*ep = op->va[i] ;
	        if (ep && (sch == ep[0])) {
		    cint	m = nleadstr(ep,sp,sl) ;
		    if ((m == sl) && (ep[m] == '\0')) break ;
	        }
	    } /* end for */
	    if (i < op->i) rs = i ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_findn) */

int vecpstr_findaddr(vecpstr *op,cchar *addr) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op,addr)) >= 0) {
		rs = SR_NOTFOUND ;
	        if (op->va) {
	            for (int i = 0 ; i < op->i ; i += 1) {
	                cchar	*ep = op->va[i] ;
	                if (ep && (addr == ep)) {
	                    rs = i ;
	                    break ;
	                }
	            } /* end for */
		} /* end if (populated) */
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_findaddr) */

int vecpstr_getsize(vecpstr *op) noex {
	int		rs ;
	int		sz = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	        if (op->stsize > 0) sz = op->stsize ;
	} /* end if (magic) */
	return (rs >= 0) ? sz : rs ;
}
/* end subroutine (vecpstr_getsize) */

int vecpstr_strsize(vecpstr *op) noex {
	int		rs ;
	int		stsize = 1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	        if (! op->f.stsize) {
	            for (int i = 0 ; i < op->i ; i += 1) {
			cchar	*ep = op->va[i] ;
	                if (ep) {
	                    stsize += (strlen(ep) + 1) ;
		        }
	            } /* end for */
	            op->stsize = stsize ;
	            op->f.stsize = true ;
	        } /* end if (calculating size) */
	        stsize = uceil(op->stsize,resz) ;
	} /* end if (magic) */
	return (rs >= 0) ? stsize : rs ;
}
/* end subroutine (vecpstr_strsize) */

int vecpstr_strmk(vecpstr *op,char *tab,int tabsize) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,tab)) >= 0) {
		    typedef int (*get_f)(vechand *,int,void **) ;
		    cint	stsize = uceil(op->stsize,szof(int)) ;
		    rs = SR_OVERFLOW ;
	            if (tabsize >= stsize) {
			vechand		*clp = op->clp ;
	                char		*bp = tab ;
			void		*vp{} ;
			get_f 		get = vechand_get ;
			rs = SR_OK ;
			*bp++ = '\0' ;	/* <- zeroth entry */
			c += 1 ;
	                for (int i = 0 ; get(clp,i,&vp) >= 0 ; i += 1) {
	                    vecpstr_ch	*ccp = (vecpstr_ch *) vp ;
	                    if (ccp && ccp->tab) {
	                        c += ccp->count ;
	                        memcpy(bp,ccp->tab,ccp->tablen) ;
	                        bp += ccp->tablen ;
		            }
	                } /* end for */
	                while (bp < (tab + tabsize)) {
	                    *bp++ = '\0' ;
	                }
	            } /* end if (not overflow) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_strmk) */

int vecpstr_recsize(vecpstr *op) noex {
	int		rs ;
	int		rsize = (2 * resz) ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if (op->va) {
		rsize += (op->c * resz) ;
	    } /* end if (populated) */
	} /* end if (magic) */
	return (rs >= 0) ? rsize : rs ;
}
/* end subroutine (vecpstr_recsize) */

int vecpstr_cksize(vecpstr *op) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if ((rs = op->stsize) == 0) {
	        rs = vecpstr_strsize(op) ;
	    }
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_cksize) */

int vecpstr_recmk(vecpstr *op,int *rec,int recsize) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,rec)) >= 0) {
	        cint	rsize = ((op->c + 2) * resz) ;
		rs = SR_OVERFLOW ;
	        if (recsize >= rsize) {
	            int		si = 0 ;
		    rs = SR_OK ;
	            rec[c++] = si ;
	            si += 1 ;
	            for (int i = 0 ; i < op->i ; i += 1) {
			cchar	*ep = op->va[i] ;
	                if (ep) {
	                    rec[c++] = si ;
	                    si += (strlen(ep) + 1) ;
		        }
	            } /* end for */
	            rec[c] = -1 ;
	        } /* end if (not overflow) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_recmk) */

int vecpstr_recmkstr(vecpstr *op,int *rec,int recs,char *tab,int tabs) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,rec,tab)) >= 0) {
            if (op->stsize == 0) {
                rs = vecpstr_strsize(op) ;
            }
	    if (rs >= 0) {
		cint	stsize = iceil(op->stsize,resz) ;
		rs = SR_OVERFLOW ;
	        if (tabs >= stsize) {
	            cint	rsize = ((op->i + 2) * resz) ;
	            if (recs >= rsize) {
		        char	*bp = tab ;		/* table pointer */
	                rec[c++] = 0 ;
	                *bp++ = '\0' ;
	                for (int i = 0 ; i < op->i ; i += 1) {
			    cchar	*ep = op->va[i] ;
	                    if (ep) {
	                        rec[c++] = (bp - tab) ;
	                        bp = (strwcpy(bp,ep,-1) + 1) ;
		            }
	                } /* end for */
	                rec[c] = -1 ;
	            } /* end if (record-size OK) */
	        } /* end if (string-size OK) */
	    } /* end if (ok) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_recmkstr) */

int vecpstr_avmkstr(vecpstr *op,cchar **av,int avs,char *tab,int tabs) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,av,tab)) >= 0) {
	    if ((rs = op->cksize) >= 0) {
		int	sz = iceil(op->stsize,szof(int)) ;
		rs = SR_OVERFLOW ;
	        if (tabs >= sz) {
	            sz = (op->c + 1) * szof(int) ;
	            if (avs >= sz) {
		        char	*bp = tab ;
		        rs = SR_OK ;
	                *bp++ = '\0' ;
	                for (int i = 0 ; i < op->i ; i += 1) {
		            cchar	*ep = op->va[i] ;
	                    if (ep) {
	                        av[c++] = bp ;
	                        bp = strwcpy(bp,ep,-1) + 1 ;
		            }
	                } /* end for */
	                av[c] = nullptr ;
	            }
	        }
	    } /* end if (vecpstr_cksize) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_avmkstr) */

int vecpstr_indlen(vecpstr *op) noex {
	int		rs ;
	int		il = 1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	        il = indexlen(op->i + 1) ;
	} /* end if (magic) */
	return (rs >= 0) ? il : rs ;
}
/* end subroutine (vecpstr_indlen) */

int vecpstr_indsize(vecpstr *op) noex {
	int		rs ;
	int		isize = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	        cint	il = indexlen(op->i + 1) ;
	        isize = indexsize(il) ;
	} /* end if (magic) */
	return (rs >= 0) ? isize : rs ;
}
/* end subroutine (vecpstr_indsize) */

int vecpstr_getvec(vecpstr *op,mainv *rppp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,rppp)) >= 0) {
	    if ((rs = vecpstr_extvec(op,1)) >= 0) {
	        *rppp = mainv(op->va) ;
		i = op->i ;
	    }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_getvec) */


/* private subroutines */

static int vecpstr_ctor(vecpstr *op) noex {
	int		rs = SR_FAULT ;
	if (op) {
	    cnullptr	np{} ;
	    rs = SR_NOMEM ;
	    op->va = nullptr ;
	    op->c = 0 ;
	    op->i = 0 ;
	    op->n = 0 ;
	    op->fi = 0 ;
	    op->stsize = 0 ;
	    op->chp = nullptr ;
	    op->magic = 0 ;
	    op->chsize = 0 ;
	    op->an = 0 ;
	    if ((op->clp = new(nothrow) vechand) != np) {
	        rs = SR_OK ;
	    } /* end if (new) */
	} /* end if (non-null) */
	return rs ;
}
/* end subroutine (vecpstr_ctor) */

static int vecpstr_dtor(vecpstr *op) noex {
	int		rs = SR_OK ;
	if (op->clp) {
	    delete op->clp ;
	    op->clp = nullptr ;
	}
	return rs ;
}
/* end subroutine (vecpstr_dtor) */

static int vecpstr_setopts(vecpstr *op,int vo) noex {
	int		rs = SR_INVALID ;
	if ((vo & (~ optmask)) == 0) {
	    rs = SR_OK ;
	    op->f = {} ;
	    if (vo & VECPSTR_OREUSE) op->f.oreuse = 1 ;
	    if (vo & VECPSTR_OSWAP) op->f.oswap = 1 ;
	    if (vo & VECPSTR_OSTATIONARY) op->f.ostationary = 1 ;
	    if (vo & VECPSTR_OCOMPACT) op->f.ocompact = 1 ;
	    if (vo & VECPSTR_OSORTED) op->f.osorted = 1 ;
	    if (vo & VECPSTR_OORDERED) op->f.oordered = 1 ;
	    if (vo & VECPSTR_OCONSERVE) op->f.oconserve = 1 ;
	} /* end if (valid vopts) */
	return rs ;
}
/* end subroutine (vecpstr_setopts) */

static int vecpstr_insertsp(vecpstr *op,int ii,cchar *sp) noex {
	if (ii == op->i) {
	    op->i += 1 ;
	    op->va[op->i] = nullptr ;
	} else if (op->va[ii] != nullptr) {
	    int		i ; /* used-afterwards */
	    for (i = (ii + 1) ; i < op->i ; i += 1) {
		if (op->va[i] == nullptr) break ;
	    }
	    if (i == op->i) {
	        op->i += 1 ;
	        op->va[op->i] = nullptr ;
	    }
	    for (int j = i ; j > ii ; j -= 1) {
		op->va[j] = op->va[j-1] ;
	    }
	} /* end if */
	op->va[ii] = sp ;
	op->c += 1 ;
	op->f.issorted = false ;
	return ii ;
}
/* end subroutine (vecpstr_insertsp) */

static int vecpstr_finchunks(vecpstr *op) noex {
	vechand		*clp = op->clp ;
	int		rs = SR_OK ;
	int		rs1 ;
	int		c = 0 ;
	void		*vp ;
	for (int i = 0 ; vechand_get(clp,i,&vp) >= 0 ; i += 1) {
	    vecpstr_ch	*ccp = (vecpstr_ch *) vp ;
	    if (ccp) {
	        c += 1 ;
		{
	            rs1 = chunk_finish(ccp) ;
	            if (rs >= 0) rs = rs1 ;
		}
		{
	            rs1 = uc_libfree(ccp) ;
	            if (rs >= 0) rs = rs1 ;
		}
	    }
	} /* end for */
	op->chp = nullptr ;
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_finchunks) */

static int vecpstr_extstr(vecpstr *op,int amount) noex {
	int		rs = SR_OK ;
	if (op->chp) {
	    if (chunk_check(op->chp,amount) > 0) op->chp = nullptr ;
	} /* end if (check if could add to existing chunk) */
	if ((rs >= 0) && (amount > 0) && (op->chp == nullptr)) {
	    rs = vecpstr_newchunk(op,amount) ;
	}
	return rs ;
}
/* end subroutine (vecpstr_extstr) */

static int vecpstr_newchunk(vecpstr *op,int amount) noex {
	cint		sz = szof(vecpstr_ch) ;
	int		rs ;
	void		*vp{} ;
	op->chp = nullptr ;
	if ((rs = uc_libmalloc(sz,&vp)) >= 0) {
	    op->chp = (vecpstr_ch *) vp ;
	    if (amount < op->chsize) amount = op->chsize ;
	    if ((rs = chunk_start(op->chp,amount)) >= 0) {
	        rs = vechand_add(op->clp,op->chp) ;
		if (rs < 0)
		    chunk_finish(op->chp) ;
	    } /* end if (chunk) */
	    if (rs < 0) {
	        uc_libfree(op->chp) ;
	        op->chp = nullptr ;
	    }
	} /* end if (memory-allocation) */
	return rs ;
}
/* end subroutine (vecpstr_newchunk) */

static int vecpstr_extvec(vecpstr *op,int n) noex {
	int		rs = SR_OK ;
	if ((op->i + 1) > op->n) {
	    int		nn ;
	    int		vasize ;
	    void	*na{} ;
	    if (op->va == nullptr) {
	        cint	dn = (n > 0) ? n : VECPSTR_DEFENTS ;
	        nn = op->an ;
	        if (nn < dn) nn = dn ;
	        vasize = (nn + 1) * szof(char **) ;
	        rs = uc_libmalloc(vasize,&na) ;
	    } else {
	        nn = (op->n + 1) * 2 ;
	        vasize = (nn + 1) * szof(char **) ;
	        rs = uc_librealloc(op->va,vasize,&na) ;
	        op->va = nullptr ;
	    } /* end if */
	    if (rs >= 0) {
	        op->va = ccharpp(na) ;
	        op->va[op->i] = nullptr ;
	        op->n = nn ;
	    }
	} /* end if (needed) */
	return rs ;
}
/* end subroutine (vecpstr_extvec) */

static int vecpstr_record(vecpstr *op,cchar *sp) noex {
	int		rs = SR_OK ;
	int		i = 0 ;
	if ((op->i + 1) > op->n) {
	    rs = vecpstr_extvec(op,-1) ;
	}
	if (rs >= 0) {
	    i = op->i ;
	    op->va[(op->i)++] = sp ;
	    op->va[op->i] = nullptr ;
	    op->c += 1 ;
	}
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_record) */

static int vecpstr_reset(vecpstr *op) noex {
	op->c = 0 ;
	op->i = 0 ;
	op->n = 0 ;
	op->fi = 0 ;
	op->stsize = 0 ;
	return SR_OK ;
}
/* end subroutine (vecpstr_reset) */

static void vecpstr_arrsort(vecpstr *op,vecpstr_vcmp vcf) noex {
	qsort_f		scf = qsort_f(vcf) ;
	if_constexpr (f_qsort) {
	    cint	esize = szof(char *) ;
	    qsort(op->va,op->i,esize,scf) ;
	} else {
	    cint	i = op->i ;
	    cchar	**va = op->va ;
	    sort(va,(va+i),scf) ;
	}
}
/* end subroutine (vecpstr_arrsort) */

static int vecpstr_validx(vecpstr *op,int i) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    return ((i >= 0) && (i < op->i)) ? SR_OK : SR_NOTFOUND ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_validx) */

static int chunk_start(vecpstr_ch *ccp,int chsize) noex {
	int		rs ;
	void		*vp{} ;
	chsize = iceil(chsize,8) ;
	memclear(ccp) ; /* <- potentially dangerous if type changes */
	if ((rs = uc_libmalloc(chsize,&vp)) >= 0) {
	    ccp->tab = (char *) vp ;
	    ccp->tabsize = chsize ;
	    ccp->tab[0] = '\0' ;
	    ccp->tablen = 0 ;
	} /* end if (memory-allocation) */
	return rs ;
}
/* end subroutine (chunk_start) */

static int chunk_finish(vecpstr_ch *ccp) noex {
	int		rs = SR_OK ;
	int		rs1 ;
	if (ccp->tab) {
	    rs1 = uc_libfree(ccp->tab) ;
	    if (rs >= 0) rs = rs1 ;
	    ccp->tab = nullptr ;
	}
	ccp->tabsize = 0 ;
	return rs ;
}
/* end subroutine (chunk_finish) */

static int chunk_check(vecpstr_ch *ccp,int amount) noex {
	return (amount > (ccp->tabsize - ccp->tablen)) ;
}
/* end subroutine (chunk_check) */

static int chunk_add(vecpstr_ch *ccp,cchar *sp,int sl,cchar **rpp) noex {
	cint		amount = (sl + 1) ;
	int		rs = SR_OK ;
	if (amount <= (ccp->tabsize - ccp->tablen)) {
	    char	*bp = (ccp->tab + ccp->tablen) ;
	    strwcpy(bp,sp,sl) ;
	    ccp->tablen += amount ;
	    ccp->count += 1 ;
	    *rpp = bp ;
	} else {
	    rs = SR_BUGCHECK ;
	}
	return rs ;
}
/* end subroutine (chunk_add) */

static int chunk_addkeyval(vecpstr_ch *ccp,cchar *kp,int kl,
		cchar *vp,int vl,cchar **rpp) noex {
	cint		amount = (kl+1+vl+1) ;
	int		rs = SR_OK ;
	if (amount <= (ccp->tabsize - ccp->tablen)) {
	    char	*bp = (ccp->tab + ccp->tablen) ;
	    bp = strwcpy(bp,kp,kl) ;
	    *bp++ = '=' ;
	    if (vp != nullptr) {
	        strwcpy(bp,vp,vl) ;
	    } else {
		*bp++ = '\0' ;
	    }
	    ccp->tablen += amount ;
	    ccp->count += 1 ;
	    *rpp = bp ;
	} else {
	    rs = SR_BUGCHECK ;
	}
	return rs ;
}
/* end subroutine (chunk_addkeyval) */

static int indexlen(int n) noex {
	return nextpowtwo(n) ;
}
/* end subroutine (indexlen) */

static int indexsize(int il) noex {
	cint		isize = ((il + 1) * 3 * szof(int)) ;
	return isize ;
}
/* end subroutine (indexsize) */

int vecpstr::start(int vn,int vsz,int vo) noex {
	return vecpstr_start(this,vn,vsz,vo) ;
}

int vecpstr::add(cchar *sp,int sl) noex {
	return vecpstr_add(this,sp,sl) ;
}

int vecpstr::adduniq(cchar *sp,int sl) noex {
	return vecpstr_adduniq(this,sp,sl) ;
}

int vecpstr::addsyms(cchar *on,mainv sv) noex {
	return vecpstr_addsyms(this,on,sv) ;
}

int vecpstr::addpath(cchar *sp,int sl) noex {
	return vecpstr_addpath(this,sp,sl) ;
}

int vecpstr::get(int ai,cchar **rpp) noex {
	return vecpstr_get(this,ai,rpp) ;
}

int vecpstr::getlast(cchar **spp) noex {
    	return vecpstr_getlast(this,spp) ;
}

int vecpstr::getvec(mainv *rppp) noex {
	return vecpstr_getvec(this,rppp) ;
}

int vecpstr::envadd(cchar *kp,cchar *valp,int vall) noex {
	return vecpstr_envadd(this,kp,valp,vall) ;
}

int vecpstr::envset(cchar *kp,cchar *valp,int vall) noex {
	return vecpstr_envset(this,kp,valp,vall) ;
}

int vecpstr::envfile(cchar *fn) noex {
	return vecpstr_envfile(this,fn) ;
}

int vecpstr::find(cchar *s) noex {
    	return vecpstr_find(this,s) ;
}

int vecpstr::findn(cchar *sp,int sl) noex {
    	return vecpstr_findn(this,sp,sl) ;
}

int vecpstr::search(cchar *s,vecpstr_f vcmp,cchar **rpp) noex {
	return vecpstr_search(this,s,vcmp,rpp) ;
}

int vecpstr::finder(cchar *s,vecpstr_f vcmp,cchar **rpp) noex {
	return vecpstr_finder(this,s,vcmp,rpp) ;
}

int vecpstr::del(int ai) noex {
	if (ai < 0) ai = 0 ;
	return vecpstr_del(this,ai) ;
}

void vecpstr::dtor() noex {
	if (cint rs = finish ; rs < 0) {
	    ulogerror("vecpstr",rs,"fini-finish") ;
	}
}

vecpstr::operator int () noex {
    	int		rs = SR_NOTOPEN ;
	if (magic == VECPSTR_MAGIC) {
	    rs = c ;
	}
	return rs ;
}

vecpstr_co::operator int () noex {
	int		rs = SR_BUGCHECK ;
	if (op) {
	    switch (w) {
	    case vecpstrmem_addcspath:
	        rs = vecpstr_addcspath(op) ;
	        break ;
	    case vecpstrmem_count:
	        rs = vecpstr_count(op) ;
	        break ;
	    case vecpstrmem_delall:
	        rs = vecpstr_delall(op) ;
	        break ;
	    case vecpstrmem_strsize:
	        rs = vecpstr_strsize(op) ;
	        break ;
	    case vecpstrmem_recsize:
	        rs = vecpstr_recsize(op) ;
	        break ;
	    case vecpstrmem_cksize:
	        rs = vecpstr_cksize(op) ;
	        break ;
	    case vecpstrmem_audit:
	        rs = vecpstr_audit(op) ;
	        break ;
	    case vecpstrmem_finish:
	        rs = vecpstr_finish(op) ;
	        break ;
	    } /* end switch */
	} /* end if (non-null) */
	return rs ;
}
/* end method (vecpstr_co::operator) */

bool vecpstr_iter::operator == (const vecpstr_iter &oit) noex {
	return (va == oit.va) && (i == oit.i) && (ii == oit.ii) ;
}

bool vecpstr_iter::operator != (const vecpstr_iter &oit) noex {
	bool		f = false ;
	f = f || (va != oit.va) ;
	f = f || (ii != oit.ii) ;
	if (!f) {
	    f = (i < oit.i) ;
	}
	return f ;
}
/* end method (vecpstr_iter::operator) */

vecpstr_iter vecpstr_iter::operator + (int n) const noex {
	vecpstr_iter	rit(va,i,i) ;
	rit.i = ((rit.i + n) >= 0) ? (rit.i + n) : 0 ;
	return rit ;
}

vecpstr_iter vecpstr_iter::operator += (int n) noex {
	vecpstr_iter	rit(va,i,i) ;
	i = ((i + n) >= 0) ? (i + n) : 0 ;
	rit.i = i ;
	return rit ;
}

vecpstr_iter vecpstr_iter::operator ++ () noex { /* pre */
	increment() ;
	return (*this) ;
}

vecpstr_iter vecpstr_iter::operator ++ (int) noex { /* post */
	vecpstr_iter	pre(*this) ;
	increment() ;
	return pre ;
}

void vecpstr_iter::increment(int n) noex {
	if ((i + n) < 0) n = -i ;
	if (n != 0) {
	    i += n ;
	    while ((i < ii) && (va[i] == nullptr)) {
	        i += 1 ;
	    }
	}
}
/* end method (vecpstr_iter::increment) */


