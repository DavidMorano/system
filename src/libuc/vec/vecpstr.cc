/* vecpstr SUPPORT */
/* charset=ISO8859-1 */
/* lang=C++20 */

/* vector-packed-string object */
/* version %I% last-modified %G% */

#define	CF_QSORT	0		/* use |qsort(3c)| */

/* revision history:

	= 1998-03-24, David A­D­ Morano
        This object module was morphed from some previous one. I do not remember
        what the previous one was.

*/

/* Copyright © 1998 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Name:
	vecpstr

	Description:
	This object module creates and manages a string table object.
	This string table can later be written to a file or otherwise
	stored some way so that it can be used in-place later.  This
	is often useful for cache files or ELF code object files.

	Arguments:
	stp		pointer to the vecpstr object
	<others>

	Returns:
	>=0		the total length of the filled up vecpstr so far!
	<0		error (system-return)

	Notes:
	The index table (optionally) generated by this OBJECT using
	-> hash-linking <- to track down matches.  It does not use
	-> key-linking <-.  So searching the generated index table
	must also use hash-linking.


	Name:
	vecpstr_adduniq

	Description:
	This subroutine adds a string to the object, but first
	checks to see if it is already present.  Specified strings
	that already match an existing entry are not added.

	Synopsis:
	int vecpstr_adduniq(vecpstr *op,cchar *sp,int sl) noex

	Arguments:
	op		vecpstr string to add to
	sp		pointer to key string to add
	sl		length of string to add

	Returns:
	INT_MAX		string was already in container
	>=0		OK
	<0		error (system-return)

*******************************************************************************/

#include	<envstandards.h>	/* ordered first to configure */
#include	<unistd.h>
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<new>			/* |nothrow(3c++)| */
#include	<algorithm>		/* |min(3c++)| + |max(3c++)| */
#include	<string>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>
#include	<usyscalls.h>
#include	<uclibmem.h>
#include	<vechand.h>
#include	<vstrcmpx.h>
#include	<nleadstr.h>
#include	<strwcpy.h>
#include	<intceil.h>
#include	<nextpowtwo.h>
#include	<localmisc.h>

#include	"vecpstr.h"

import libutil ;			/* |lenstr(3u)| + |getlenstr(3u)| */

/* local defines */

#define	VPS_CHSIZE	512		/* starting table size */
#define	VPS_CH		vecpstr_ch 
#define	MODP2(v,n)	((v) & ((n) - 1))


/* imported namespaces */

using std::string ;			/* type */
using std::sort ;			/* subroutine-template */
using std::min ;			/* subroutine-template */
using libuc::libmem ;			/* variable */
using std::nothrow ;			/* constant */


/* local typedefs */

typedef VPS_CH	chunk ;

extern "C" {
    typedef int (*qsort_f)(cvoid *,cvoid *) noex ;
}


/* external subroutines */

extern "C++" {
    int		vecpstr_add(vecpstr *,string *) noex ;
}


/* external variables */


/* local structures */

struct strentry {
	uint	khash ;
	uint	hi ;
	uint	si ;
} ;


/* forward references */

static int	vecpstr_ctor(vecpstr *) noex ;
static int	vecpstr_dtor(vecpstr *) noex ;
static int	vecpstr_setopts(vecpstr *,int) noex ;
static int	vecpstr_insertsp(vecpstr *,int,cchar *) noex ;
static int	vecpstr_finchunks(vecpstr *) noex ;
static int	vecpstr_extstr(vecpstr *,int) noex ;
static int	vecpstr_newchunk(vecpstr *,int) noex ;
static int	vecpstr_extvec(vecpstr *,int = 0) noex ;
static int	vecpstr_record(vecpstr *,cchar *) noex ;
static int	vecpstr_reset(vecpstr *) noex ;
static int	vecpstr_validx(vecpstr *,int) noex ;
static void	vecpstr_arrsort(vecpstr *,vecpstr_vcmp) noex ;

template<typename ... Args>
static inline int vecpstr_magic(vecpstr *op,Args ... args) noex {
	int		rs = SR_FAULT ;
	if (op && (args && ...)) {
	    rs = (op->magic == VECPSTR_MAGIC) ? SR_OK : SR_NOTOPEN ;
	}
	return rs ;
} /* end subroutine (vecpstr_magic) */

static int chunk_start(VPS_CH *,int) noex ;
static int chunk_finish(VPS_CH *) noex ;
static int chunk_check(VPS_CH *,int) noex ;
static int chunk_add(VPS_CH *,cchar *,int,cchar **) noex ;
static int chunk_addkeyval(VPS_CH *,cchar *,int,cchar *,int,cchar **) noex ;

static int	indexlen(int) noex ;
static int	indexsize(int) noex ;
static int	mkoptmask() noex ;


/* local subroutines */


/* local variables */

constexpr bool		f_qsort = CF_QSORT ;

constexpr int		defents = VECPSTR_DEFENTS ;
constexpr int		resz = szof(int) ;

static cint		optmask = mkoptmask() ;


/* exported variables */

int vecpstrms::reuse		= (1 << vecpstro_reuse) ;
int vecpstrms::compact		= (1 << vecpstro_compact) ;
int vecpstrms::swap		= (1 << vecpstro_swap) ;
int vecpstrms::stationary	= (1 << vecpstro_stationary) ;
int vecpstrms::conserve		= (1 << vecpstro_conserve) ;
int vecpstrms::sorted		= (1 << vecpstro_sorted) ;
int vecpstrms::ordered		= (1 << vecpstro_ordered) ;

const vecpstrms		vecpstrm ;


/* exported subroutines */

int vecpstr_start(vecpstr *op,int vn,int vsz,int vo) noex {
	int		rs ;
	if ((rs = vecpstr_ctor(op)) >= 0) {
	    if (vsz < VPS_CHSIZE) vsz = VPS_CHSIZE ;
	    if (vn < 0) vn = 0 ;
	    op->chsize = vsz ;
	    op->addnum = vn ;
	    if ((rs = vecpstr_setopts(op,vo)) >= 0) {
	        cint	nc = min(((vn * 6) / vsz),1) ;
	        if ((rs = vechand_start(op->clp,nc,0)) >= 0) {
	            op->magic = VECPSTR_MAGIC ;
	        }
	    }
	    if (rs < 0) {
		vecpstr_dtor(op) ;
	    }
	} /* end if (non-null) */
	return rs ;
}
/* end subroutine (vecpstr_start) */

int vecpstr_finish(vecpstr *op) noex {
	int		rs ;
	int		rs1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if (op->va) {
	        rs1 = libmem.free(op->va) ;
	        if (rs >= 0) rs = rs1 ;
	        op->va = nullptr ;
	    }
	    {
	        rs1 = vecpstr_finchunks(op) ;
	        if (rs >= 0) rs = rs1 ;
	    }
	    if (op->clp) {
	        rs1 = vechand_finish(op->clp) ;
	        if (rs >= 0) rs = rs1 ;
	    }
	    {
		rs1 = vecpstr_dtor(op) ;
		if (rs >= 0) rs = rs1 ;
	    }
	    op->cnt = 0 ;
	    op->idx = 0 ;
	    op->ext = 0 ;
	    op->magic = 0 ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_finish) */

int vecpstr_audit(vecpstr *op) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
            for (int i = 0 ; i < op->idx ; i += 1) {
                if (op->va[i] != nullptr) {
                    cchar   *cp = op->va[i] ;
                    c += 1 ;
                    {
                        const uintptr_t vv = uintptr_t(cp) ;
                        {
                            cint    v = int(vv & INT_MAX) ;
                            rs |= v ;       /* access might SEGFAULT */
                        }
                    }
                } /* end if (non-empty entry) */
            } /* end for */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_audit) */

int vecpstr_add(vecpstr *op,cchar *sp,int sl) noex {
	return vecpstr_store(op,sp,sl,nullptr) ;
}
/* end subroutine (vecpstr_add) */

int vecpstr_adduniq(vecpstr *op,cchar *sp,int sl) noex {
	int		rs = SR_FAULT ;
	if (op && sp) {
	    if (sl < 0) sl = lenstr(sp) ;
	    if ((rs = vecpstr_findn(op,sp,sl)) >= 0) {
	        rs = INT_MAX ;
	    } else if (rs == SR_NOTFOUND) {
	        rs = vecpstr_add(op,sp,sl) ;
	    }
	} /* end if (non-null) */
	return rs ;
}
/* end subroutine (vecpstr_adduniq) */

int vecpstr_addkeyval(vecpstr *op,cchar *kp,int kl,cchar *vp,int vl) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,kp)) >= 0) {
            int     amount = 0 ;
            if (kl < 0) kl = lenstr(kp) ;
            amount += (kl+1) ;
            if (vp) {
                if (vl < 0) vl = lenstr(vp) ;
                amount += (vl+1) ;
            }
            if ((rs = vecpstr_extstr(op,amount)) >= 0) {
                cchar       *cp{} ;
                if ((rs = chunk_addkeyval(op->chp,kp,kl,vp,vl,&cp)) >= 0) {
                    if ((rs = vecpstr_record(op,cp)) >= 0) {
                        i = rs ;
                        op->stsize += amount ;
                    }
                }
            } /* end if (vecpstr_extstr) */
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_addkeyval) */

int vecpstr_insert(vecpstr *op,int ii,cchar *sp,int sl) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_validx(op,ii)) >= 0) {
	    if (sl < 0) sl = lenstr(sp) ;
	    if ((op->idx + 1) > op->ext) {
	        rs = vecpstr_extvec(op) ;
	    }
	    if (rs >= 0) {
	        cint	sz = (sl+1) ;
	        if (char *bp ; (rs = libmem.mall(sz,&bp)) >= 0) {
	            strwcpy(bp,sp,sl) ;
	            op->stsize += sz ;
	            i = vecpstr_insertsp(op,ii,bp) ;
	        } /* end if (memory-allocation) */
	    } /* end if (OK) */
	} /* end if (valid index) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_insert) */

int vecpstr_store(vecpstr *op,cchar *sp,int sl,cchar **rpp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
	    if (sl < 0) sl = lenstr(sp) ;
	    {
	        cint	amount = (sl + 1) ;
	        cchar	*cp = nullptr ;
	        if ((rs = vecpstr_extstr(op,amount)) >= 0) {
	            if ((rs = chunk_add(op->chp,sp,sl,&cp)) >= 0) {
	                if ((rs = vecpstr_record(op,cp)) >= 0) {
	                     i = rs ;
	                     op->stsize += amount ;
			}
	            }
	        }
	        if (rpp) {
	            *rpp = (rs >= 0) ? cp : nullptr ;
	        }
	    } /* end block */
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_store) */

int vecpstr_already(vecpstr *op,cchar *sp,int sl) noex {
	return vecpstr_findn(op,sp,sl) ;
}
/* end subroutine (vecpstr_already) */

int vecpstr_get(vecpstr *op,int i,cchar **rpp) noex {
	int		rs ;
	if ((rs = vecpstr_validx(op,i)) >= 0) {
	    if (rpp) {
	        *rpp = (rs >= 0) ? op->va[i] : nullptr ;
	    }
	} /* end if (validx) */
	return rs ;
}
/* end subroutine (vecpstr_get) */

int vecpstr_getlast(vecpstr *op,cchar **spp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    rs = SR_NOTFOUND ;
	    if (op->va && (op->cnt > 0)) {
	        i = (op->idx-1) ;
	        while ((i >= 0) && (op->va[i] == nullptr)) {
		    i -= 1 ;
	        }
	        if (i >= 0) rs = SR_OK ;
	    } /* end if (populated) */
	    if (spp) {
	        *spp = (rs >= 0) ? op->va[i] : nullptr ;
	    }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_getlast) */

int vecpstr_del(vecpstr *op,int i) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_validx(op,i)) >= 0) {
            bool        f_fi = false ;
            if (op->va[i] != nullptr) {
                op->cnt -= 1 ;            /* decrement list count */
                if (op->fl.stsize) {
                    op->stsize -= (lenstr(op->va[i]) + 1) ;
                }
            } /* end if (freeing the actual string data) */
            if (op->fl.ostationary) {
                op->va[i] = nullptr ;
                if (i == (op->idx - 1)) op->idx -= 1 ;
                f_fi = true ;
            } else if (op->fl.issorted || op->fl.oordered) {
                if (op->fl.ocompact) {
                    op->idx -= 1 ;
                    for (int j = i ; j < op->idx ; j += 1) {
                        op->va[j] = op->va[j + 1] ;
                    }
                    op->va[op->idx] = nullptr ;
                } else {
                    op->va[i] = nullptr ;
                    if (i == (op->idx - 1)) op->idx -= 1 ;
                    f_fi = true ;
                } /* end if */
            } else {
                bool    f = (op->fl.oswap || op->fl.ocompact) ;
                if (f && (i < (op->idx - 1))) {
                    op->va[i] = op->va[op->idx - 1] ;
                    op->va[--op->idx] = nullptr ;
                    op->fl.issorted = false ;
                } else {
                    op->va[i] = nullptr ;
                    if (i == (op->idx - 1)) op->idx -= 1 ;
                    f_fi = true ;
                } /* end if */
            } /* end if */
            if (op->fl.oconserve) {
                while (op->idx > i) {
                    if (op->va[op->idx - 1] != nullptr) break ;
                    op->idx -= 1 ;
                } /* end while */
            } /* end if */
            if (f_fi && (i < op->fidx)) {
                op->fidx = i ;
            }
            c = op->cnt ;
            op->fl.stsize = false ;
	} else if (rs == SR_NOTFOUND) {
	    rs = vecpstr_delall(op) ;
	} /* end if (validx) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_del) */

int vecpstr_delall(vecpstr *op) noex {
	int		rs ;
	int		rs1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    {
	        rs1 = vecpstr_finchunks(op) ;
	        if (rs >= 0) rs = rs1 ;
	        op->chp = nullptr ;
	    }
	    if (op->clp) {
	        rs1 = vechand_delall(op->clp) ;
	        if (rs >= 0) rs = rs1 ;
	    }
	    if (op->va) {
	        rs1 = libmem.free(op->va) ;
	        if (rs >= 0) rs = rs1 ;
	        op->va = nullptr ;
	    }
	    if (rs >= 0) {
	        rs = vecpstr_reset(op) ;
	    }
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_delall) */

int vecpstr_count(vecpstr *op) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    rs = op->cnt ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_count) */

int vecpstr_sort(vecpstr *op,vecpstr_vcmp vcf) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if (op->va) {
		if (vcf == nullptr) vcf = vstrcmp ;
	        if ((! op->fl.issorted) && (op->cnt > 1)) {
		    c = op->cnt ;
		    vecpstr_arrsort(op,vcf) ;
	        } /* end if (sorting) */
	        op->fl.issorted = true ;
	    } /* end if (populated) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_sort) */

int vecpstr_search(vecpstr *op,cchar *sp,vecpstr_vcmp vcf,cchar **rpp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
	    rs = SR_NOTFOUND ;
	    if (op->va) {
		cchar	**rpp2 ;
		if (vcf == nullptr) vcf = vstrcmp ;
	        if (op->fl.issorted) {
		    csize	nsize = size_t(op->idx) ;
	            csize	esize = sizeof(char *) ;
	            qsort_f	scf = qsort_f(vcf) ;
	            rpp2 = (cchar **) bsearch(&sp,op->va,nsize,esize,scf) ;
	            rs = SR_NOTFOUND ;
	            if (rpp2) {
	                i = intconv(rpp2 - op->va) ;
	                rs = SR_OK ;
	            }
	        } else {
	            for (i = 0 ; i < op->idx ; i += 1) {
	                rpp2 = (op->va + i) ;
	                if (*rpp2) {
	                    if ((*vcf)(&sp,rpp2) == 0) break ;
		        }
	            } /* end for */
	            rs = (i < op->idx) ? SR_OK : SR_NOTFOUND ;
	        } /* end if (sorted or not) */
	    } /* end if (was populated) */
	    if (rpp) {
	        *rpp = (rs >= 0) ? op->va[i] : nullptr ;
	    }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_search) */

int vecpstr_finder(vecpstr *op,cchar *sp,vecpstr_vcmp vcf,cchar **rpp) noex {
	int		rs = SR_FAULT ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
            rs = SR_NOTFOUND ;
            if (op->va) {
               int          i ; /* <- used-afterwards */
               if (vcf == nullptr) vcf = vstrcmp ;
               for (i = 0 ; i < op->idx ; i += 1) {
                    if (op->va[i]) {
                       if ((*vcf)(&sp,(op->va+i)) == 0) break ;
                    }
               } /* end for */
               if (i < op->idx) rs = i ;
               if (rpp) {
                   *rpp = (rs >= 0) ? op->va[i] : nullptr ;
               }
            } /* end if (populated) */
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_finder) */

int vecpstr_find(vecpstr *op,cchar *sp) noex {
        int             rs ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
            rs = SR_NOTFOUND ;
            if (op->va) {
                cint        sch = sp[0] ; /* ok: all promoted similarly */
                int         i ; /* used-afterwards */
                for (i = 0 ; i < op->idx ; i += 1) {
                    cchar   *ep = op->va[i] ;
                    if (ep) {
                        if ((sch == ep[0]) && (strcmp(sp,ep) == 0)) break ;
                    }
                } /* end for */
                if (i < op->idx) rs = i ;
            } /* end if (populated) */
	} /* end if (magic) */
        return rs ;
}
/* end subroutine (vecpstr_find) */

int vecpstr_findn(vecpstr *op,cchar *sp,int sl) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op,sp)) >= 0) {
	    int		sch = sp[0] ; /* ok: since all get promoted similarly */
	    int		i ; /* <- used-afterwards */
	    rs = SR_NOTFOUND ;
	    if (sl < 0) sl = lenstr(sp) ;
	    for (i = 0 ; i < op->idx ; i += 1) {
	        cchar	*ep = op->va[i] ;
	        if (ep && (sch == ep[0])) {
		    cint	m = nleadstr(ep,sp,sl) ;
		    if ((m == sl) && (ep[m] == '\0')) break ;
	        }
	    } /* end for */
	    if (i < op->idx) rs = i ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_findn) */

int vecpstr_findaddr(vecpstr *op,cchar *addr) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op,addr)) >= 0) {
            rs = SR_NOTFOUND ;
            if (op->va) {
                for (int i = 0 ; i < op->idx ; i += 1) {
                    cchar   *ep = op->va[i] ;
                    if (ep && (addr == ep)) {
                        rs = i ;
                        break ;
                    }
                } /* end for */
            } /* end if (populated) */
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_findaddr) */

int vecpstr_getsize(vecpstr *op) noex {
	int		rs ;
	int		sz = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if (op->stsize > 0) sz = op->stsize ;
	} /* end if (magic) */
	return (rs >= 0) ? sz : rs ;
}
/* end subroutine (vecpstr_getsize) */

int vecpstr_strsize(vecpstr *op) noex {
	int		rs ;
	int		stsize = 1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
            if (! op->fl.stsize) {
                for (int i = 0 ; i < op->idx ; i += 1) {
                    cchar   *ep = op->va[i] ;
                    if (ep) {
                        stsize += (lenstr(ep) + 1) ;
                    }
                } /* end for */
                op->stsize = stsize ;
                op->fl.stsize = true ;
            } /* end if (calculating size) */
            stsize = uceil(op->stsize,resz) ;
	} /* end if (magic) */
	return (rs >= 0) ? stsize : rs ;
}
/* end subroutine (vecpstr_strsize) */

int vecpstr_strmk(vecpstr *op,char *tab,int tabsize) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,tab)) >= 0) {
            typedef int (*get_f)(vechand *,int,void **) ;
            cint        stsize = uceil(op->stsize,szof(int)) ;
            rs = SR_OVERFLOW ;
            if (tabsize >= stsize) {
                vechand         *clp = op->clp ;
                char            *bp = tab ;
                void            *vp{} ;
                get_f           get = vechand_get ;
                rs = SR_OK ;
                *bp++ = '\0' ;  /* <- zeroth entry */
                c += 1 ;
                for (int i = 0 ; get(clp,i,&vp) >= 0 ; i += 1) {
                    VPS_CH  *chkp = (vecpstr_ch *) vp ;
                    if (chkp && chkp->tab) {
                        c += chkp->count ;
                        memcpy(bp,chkp->tab,chkp->tablen) ;
                        bp += chkp->tablen ;
                    }
                } /* end for */
                while (bp < (tab + tabsize)) {
                    *bp++ = '\0' ;
                }
            } /* end if (not overflow) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_strmk) */

int vecpstr_recsize(vecpstr *op) noex {
	int		rs ;
	int		rsz = (2 * resz) ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if (op->va) {
		rsz += (op->cnt * resz) ;
	    } /* end if (populated) */
	} /* end if (magic) */
	return (rs >= 0) ? rsz : rs ;
}
/* end subroutine (vecpstr_recsize) */

int vecpstr_cksize(vecpstr *op) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    if ((rs = op->stsize) == 0) {
	        rs = vecpstr_strsize(op) ;
	    }
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_cksize) */

int vecpstr_recmk(vecpstr *op,int *rec,int recsize) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,rec)) >= 0) {
            cint    rsz = ((op->cnt + 2) * resz) ;
            rs = SR_OVERFLOW ;
            if (recsize >= rsz) {
                int         si = 0 ;
                rs = SR_OK ;
                rec[c++] = si ;
                si += 1 ;
                for (int i = 0 ; i < op->idx ; i += 1) {
                    cchar   *ep = op->va[i] ;
                    if (ep) {
                        rec[c++] = si ;
                        si += (lenstr(ep) + 1) ;
                    }
                } /* end for */
                rec[c] = -1 ;
            } /* end if (not overflow) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_recmk) */

int vecpstr_recmkstr(vecpstr *op,int *rec,int recs,char *tab,int tabs) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,rec,tab)) >= 0) {
            if (op->stsize == 0) {
                rs = vecpstr_strsize(op) ;
            }
	    if (rs >= 0) {
		cint	stsize = iceil(op->stsize,resz) ;
		rs = SR_OVERFLOW ;
	        if (tabs >= stsize) {
	            cint	rsz = ((op->idx + 2) * resz) ;
	            if (recs >= rsz) {
		        char	*bp = tab ;		/* table pointer */
	                rec[c++] = 0 ;
	                *bp++ = '\0' ;
	                for (int i = 0 ; i < op->idx ; i += 1) {
			    cchar	*ep = op->va[i] ;
	                    if (ep) {
	                        rec[c++] = intconv(bp - tab) ;
	                        bp = (strwcpy(bp,ep,-1) + 1) ;
		            }
	                } /* end for */
	                rec[c] = -1 ;
	            } /* end if (record-size OK) */
	        } /* end if (string-size OK) */
	    } /* end if (ok) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_recmkstr) */

int vecpstr_avmkstr(vecpstr *op,cchar **av,int avs,char *tab,int tabs) noex {
	int		rs ;
	int		c = 0 ;
	if ((rs = vecpstr_magic(op,av,tab)) >= 0) {
	    if ((rs = op->cksize) >= 0) {
		int	sz = iceil(op->stsize,szof(int)) ;
		rs = SR_OVERFLOW ;
	        if (tabs >= sz) {
	            sz = (op->cnt + 1) * szof(int) ;
	            if (avs >= sz) {
		        char	*bp = tab ;
		        rs = SR_OK ;
	                *bp++ = '\0' ;
	                for (int i = 0 ; i < op->idx ; i += 1) {
		            cchar	*ep = op->va[i] ;
	                    if (ep) {
	                        av[c++] = bp ;
	                        bp = strwcpy(bp,ep,-1) + 1 ;
		            }
	                } /* end for */
	                av[c] = nullptr ;
	            }
	        }
	    } /* end if (vecpstr_cksize) */
	} /* end if (magic) */
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_avmkstr) */

int vecpstr_indlen(vecpstr *op) noex {
	int		rs ;
	int		il = 1 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    il = indexlen(op->idx + 1) ;
	} /* end if (magic) */
	return (rs >= 0) ? il : rs ;
}
/* end subroutine (vecpstr_indlen) */

int vecpstr_indsize(vecpstr *op) noex {
	int		rs ;
	int		isize = 0 ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    cint	il = indexlen(op->idx + 1) ;
	    isize = indexsize(il) ;
	} /* end if (magic) */
	return (rs >= 0) ? isize : rs ;
}
/* end subroutine (vecpstr_indsize) */

int vecpstr_getvec(vecpstr *op,mainv *rppp) noex {
	int		rs ;
	int		i = 0 ;
	if ((rs = vecpstr_magic(op,rppp)) >= 0) {
	    if ((rs = vecpstr_extvec(op,1)) >= 0) {
	        *rppp = mainv(op->va) ;
		i = op->idx ;
	    }
	} /* end if (magic) */
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_getvec) */

int vecpstr_add(vecpstr *op,string *strp) noex {
	int		rs = SR_FAULT ;
	if (op && strp) {
	    cchar	*sp = strp->c_str() ;
	    cint	sl = intconv(strp->size()) ;
	    rs = vecpstr_add(op,sp,sl) ;
	}
	return rs ;
} /* end subroutine (vecpstr_add) */


/* private subroutines */

static int vecpstr_ctor(vecpstr *op) noex {
	int		rs = SR_FAULT ;
	if (op) {
	    cnullptr	np{} ;
	    rs = SR_NOMEM ;
	    op->va = nullptr ;
	    op->cnt = 0 ;
	    op->idx = 0 ;
	    op->ext = 0 ;
	    op->fidx = 0 ;
	    op->stsize = 0 ;
	    op->chp = nullptr ;
	    op->magic = 0 ;
	    op->chsize = 0 ;
	    op->addnum = 0 ;
	    if ((op->clp = new(nothrow) vechand) != np) {
	        rs = SR_OK ;
	    } /* end if (new) */
	} /* end if (non-null) */
	return rs ;
}
/* end subroutine (vecpstr_ctor) */

static int vecpstr_dtor(vecpstr *op) noex {
	int		rs = SR_OK ;
	if (op->clp) {
	    delete op->clp ;
	    op->clp = nullptr ;
	}
	return rs ;
}
/* end subroutine (vecpstr_dtor) */

static int mkoptmask() noex {
	int		m = 0 ;
	m |= vecpstrm.reuse ;
	m |= vecpstrm.compact ;
	m |= vecpstrm.swap ;
	m |= vecpstrm.stationary ;
	m |= vecpstrm.conserve ;
	m |= vecpstrm.sorted ;
	m |= vecpstrm.ordered ;
	return m ;
}
/* end subroutine (mkoptmask) */

static int vecpstr_setopts(vecpstr *op,int vo) noex {
	int		rs = SR_INVALID ;
	if ((vo & (~ optmask)) == 0) {
	    rs = SR_OK ;
	    op->fl = {} ;
	    if (vo & vecpstrm.reuse)		op->fl.oreuse = true ;
	    if (vo & vecpstrm.swap)		op->fl.oswap = true ;
	    if (vo & vecpstrm.stationary)	op->fl.ostationary = true ;
	    if (vo & vecpstrm.compact)		op->fl.ocompact = true ;
	    if (vo & vecpstrm.sorted)		op->fl.osorted = true ;
	    if (vo & vecpstrm.ordered)		op->fl.oordered = true ;
	    if (vo & vecpstrm.conserve)		op->fl.oconserve = true ;
	} /* end if (valid options) */
	return rs ;
}
/* end subroutine (vecpstr_setopts) */

static int vecpstr_insertsp(vecpstr *op,int ii,cchar *sp) noex {
	if (ii == op->idx) {
	    op->idx += 1 ;
	    op->va[op->idx] = nullptr ;
	} else if (op->va[ii] != nullptr) {
	    int		i ; /* used-afterwards */
	    for (i = (ii + 1) ; i < op->idx ; i += 1) {
		if (op->va[i] == nullptr) break ;
	    }
	    if (i == op->idx) {
	        op->idx += 1 ;
	        op->va[op->idx] = nullptr ;
	    }
	    for (int j = i ; j > ii ; j -= 1) {
		op->va[j] = op->va[j-1] ;
	    }
	} /* end if */
	op->va[ii] = sp ;
	op->cnt += 1 ;
	op->fl.issorted = false ;
	return ii ;
}
/* end subroutine (vecpstr_insertsp) */

static int vecpstr_finchunks(vecpstr *op) noex {
	vechand		*clp = op->clp ;
	int		rs = SR_OK ;
	int		rs1 ;
	int		c = 0 ;
	void		*vp ;
	for (int i = 0 ; vechand_get(clp,i,&vp) >= 0 ; i += 1) {
	    VPS_CH	*chkp = (vecpstr_ch *) vp ;
	    if (chkp) {
	        c += 1 ;
		{
	            rs1 = chunk_finish(chkp) ;
	            if (rs >= 0) rs = rs1 ;
		}
		{
	            rs1 = libmem.free(chkp) ;
	            if (rs >= 0) rs = rs1 ;
		}
	    }
	} /* end for */
	op->chp = nullptr ;
	return (rs >= 0) ? c : rs ;
}
/* end subroutine (vecpstr_finchunks) */

static int vecpstr_extstr(vecpstr *op,int amount) noex {
	int		rs = SR_OK ;
	if (op->chp) {
	    if (chunk_check(op->chp,amount) > 0) op->chp = nullptr ;
	} /* end if (check if could add to existing chunk) */
	if ((rs >= 0) && (amount > 0) && (op->chp == nullptr)) {
	    rs = vecpstr_newchunk(op,amount) ;
	}
	return rs ;
}
/* end subroutine (vecpstr_extstr) */

static int vecpstr_newchunk(vecpstr *op,int amount) noex {
	cint		sz = szof(VPS_CH) ;
	int		rs ;
	op->chp = nullptr ;
	if (void *vp ; (rs = libmem.mall(sz,&vp)) >= 0) {
	    op->chp = (VPS_CH *) vp ;
	    if (amount < op->chsize) amount = op->chsize ;
	    if ((rs = chunk_start(op->chp,amount)) >= 0) {
	        rs = vechand_add(op->clp,op->chp) ;
		if (rs < 0) {
		    chunk_finish(op->chp) ;
		}
	    } /* end if (chunk) */
	    if (rs < 0) {
	        libmem.free(op->chp) ;
	        op->chp = nullptr ;
	    }
	} /* end if (memory-allocation) */
	return rs ;
}
/* end subroutine (vecpstr_newchunk) */

static int vecpstr_extvec(vecpstr *op,int n) noex {
	int		rs = SR_OK ;
	if ((op->idx + 1) > op->ext) {
	    int		nn ;
	    int		vasz ;
	    void	*na{} ;
	    if (op->va == nullptr) {
	        cint	dn = (n > 0) ? n : VECPSTR_DEFENTS ;
	        nn = op->addnum ;
	        if (nn < dn) nn = dn ;
	        vasz = (nn + 1) * szof(char **) ;
	        rs = libmem.mall(vasz,&na) ;
	    } else {
	        nn = (op->ext + 1) * 2 ;
	        vasz = (nn + 1) * szof(char **) ;
	        rs = libmem.rall(op->va,vasz,&na) ;
	        op->va = nullptr ;
	    } /* end if */
	    if (rs >= 0) {
	        op->va = ccharpp(na) ;
	        op->va[op->idx] = nullptr ;
	        op->ext = nn ;
	    }
	} /* end if (needed) */
	return rs ;
}
/* end subroutine (vecpstr_extvec) */

static int vecpstr_record(vecpstr *op,cchar *sp) noex {
	int		rs = SR_OK ;
	int		i = 0 ;
	if ((op->idx + 1) > op->ext) {
	    rs = vecpstr_extvec(op,-1) ;
	}
	if (rs >= 0) {
	    i = op->idx ;
	    op->va[(op->idx)++] = sp ;
	    op->va[op->idx] = nullptr ;
	    op->cnt += 1 ;
	}
	return (rs >= 0) ? i : rs ;
}
/* end subroutine (vecpstr_record) */

static int vecpstr_reset(vecpstr *op) noex {
	op->cnt = 0 ;
	op->idx = 0 ;
	op->ext = 0 ;
	op->fidx = 0 ;
	op->stsize = 0 ;
	return SR_OK ;
}
/* end subroutine (vecpstr_reset) */

static void vecpstr_arrsort(vecpstr *op,vecpstr_vcmp vcf) noex {
	qsort_f		scf = qsort_f(vcf) ;
	if_constexpr (f_qsort) {
	    csize	nsize = size_t(op->idx) ;
	    csize	esize = sizeof(char *) ;
	    qsort(op->va,nsize,esize,scf) ;
	} else {
	    cint	i = op->idx ;
	    cchar	**va = op->va ;
	    sort(va,(va+i),scf) ;
	}
}
/* end subroutine (vecpstr_arrsort) */

static int vecpstr_validx(vecpstr *op,int i) noex {
	int		rs ;
	if ((rs = vecpstr_magic(op)) >= 0) {
	    return ((i >= 0) && (i < op->idx)) ? SR_OK : SR_NOTFOUND ;
	} /* end if (magic) */
	return rs ;
}
/* end subroutine (vecpstr_validx) */

static int chunk_start(VPS_CH *chkp,int chsize) noex {
	int		rs ;
	chsize = iceil(chsize,8) ;
	memclear(chkp) ; /* <- potentially dangerous if type changes */
	if (void *vp ; (rs = libmem.mall(chsize,&vp)) >= 0) {
	    chkp->tab = charp(vp) ;
	    chkp->tabsize = chsize ;
	    chkp->tab[0] = '\0' ;
	    chkp->tablen = 0 ;
	} /* end if (memory-allocation) */
	return rs ;
}
/* end subroutine (chunk_start) */

static int chunk_finish(VPS_CH *chkp) noex {
	int		rs = SR_OK ;
	int		rs1 ;
	if (chkp->tab) {
	    rs1 = libmem.free(chkp->tab) ;
	    if (rs >= 0) rs = rs1 ;
	    chkp->tab = nullptr ;
	}
	chkp->tabsize = 0 ;
	return rs ;
}
/* end subroutine (chunk_finish) */

static int chunk_check(VPS_CH *chkp,int amount) noex {
	return (amount > (chkp->tabsize - chkp->tablen)) ;
}
/* end subroutine (chunk_check) */

static int chunk_add(VPS_CH *chkp,cchar *sp,int sl,cchar **rpp) noex {
	cint		amount = (sl + 1) ;
	int		rs = SR_OK ;
	if (amount <= (chkp->tabsize - chkp->tablen)) {
	    char	*bp = (chkp->tab + chkp->tablen) ;
	    {
	        char *ep = strwcpy(bp,sp,sl) ;
	        chkp->tablen += intconv(ep - bp) ;
	        chkp->count += 1 ;
	        *rpp = bp ;
	    }
	} else {
	    rs = SR_BUGCHECK ;
	}
	return rs ;
}
/* end subroutine (chunk_add) */

static int chunk_addkeyval(VPS_CH *chkp,cc *kp,int kl,cc *vp,int vl,
		cc **rpp) noex {
	cint		amount = (kl+1+vl+1) ;
	int		rs = SR_OK ;
	if (amount <= (chkp->tabsize - chkp->tablen)) {
	    char	*bp = (chkp->tab + chkp->tablen) ;
	    {
		char *ep = strwcpy(bp,kp,kl) ;
	        *ep++ = '=' ;
	        if (vp) {
	            ep = strwcpy(ep,vp,vl) ;
	        } else {
		    *ep++ = '\0' ;
	        }
	        chkp->tablen += intconv(ep - bp) ;
	        chkp->count += 1 ;
	    } /* end block */
	    *rpp = bp ;
	} else {
	    rs = SR_BUGCHECK ;
	}
	return rs ;
}
/* end subroutine (chunk_addkeyval) */

static int indexlen(int n) noex {
	return nextpowtwo(n) ;
}
/* end subroutine (indexlen) */

static int indexsize(int il) noex {
	cint		isize = ((il + 1) * 3 * szof(int)) ;
	return isize ;
}
/* end subroutine (indexsize) */

int vecpstr::add(cchar *sp,int sl) noex {
	return vecpstr_add(this,sp,sl) ;
}

int vecpstr::adduniq(cchar *sp,int sl) noex {
	return vecpstr_adduniq(this,sp,sl) ;
}

int vecpstr::addsyms(cchar *on,mainv sv) noex {
	return vecpstr_addsyms(this,on,sv) ;
}

int vecpstr::addpath(cchar *sp,int sl) noex {
	return vecpstr_addpath(this,sp,sl) ;
}

int vecpstr::store(cchar *sp,int sl,cchar **rpp) noex {
	return vecpstr_store(this,sp,sl,rpp) ;
}

int vecpstr::already(cchar *sp,int sl) noex {
	return vecpstr_already(this,sp,sl) ;
}

int vecpstr::get(int ai,cchar **rpp) noex {
	return vecpstr_get(this,ai,rpp) ;
}

int vecpstr::getlast(cchar **spp) noex {
    	return vecpstr_getlast(this,spp) ;
}

int vecpstr::getvec(mainv *rppp) noex {
	return vecpstr_getvec(this,rppp) ;
}

int vecpstr::envadd(cchar *kp,cchar *valp,int vall) noex {
	return vecpstr_envadd(this,kp,valp,vall) ;
}

int vecpstr::envset(cchar *kp,cchar *valp,int vall) noex {
	return vecpstr_envset(this,kp,valp,vall) ;
}

int vecpstr::envfile(cchar *fn) noex {
	return vecpstr_envfile(this,fn) ;
}

int vecpstr::find(cchar *s) noex {
    	return vecpstr_find(this,s) ;
}

int vecpstr::findn(cchar *sp,int sl) noex {
    	return vecpstr_findn(this,sp,sl) ;
}

int vecpstr::search(cchar *s,vecpstr_f vcmp,cchar **rpp) noex {
	return vecpstr_search(this,s,vcmp,rpp) ;
}

int vecpstr::finder(cchar *s,vecpstr_f vcmp,cchar **rpp) noex {
	return vecpstr_finder(this,s,vcmp,rpp) ;
}

int vecpstr::sort(vecpstr_vcmp vcf) noex {
	return vecpstr_sort(this,vcf) ;
}

int vecpstr::del(int ai) noex {
	if (ai < 0) ai = 0 ;
	return vecpstr_del(this,ai) ;
}

void vecpstr::dtor() noex {
	if (cint rs = finish ; rs < 0) {
	    ulogerror("vecpstr",rs,"fini-finish") ;
	}
}

vecpstr::operator int () noex {
    	int		rs = SR_NOTOPEN ;
	if (magic == VECPSTR_MAGIC) {
	    rs = cnt ;
	}
	return rs ;
} /* end method (vecpstr::operator) */

int vecpstr_st::operator () (int vn,int vsz,int vo) noex {
	int		rs = SR_BUGCHECK ;
	if (op) {
	    rs = vecpstr_start(op,vn,vsz,vo) ;
	} /* end if (non-null) */
	return rs ;
} /* end method (vecpstr_st::operator) */

vecpstr_co::operator int () noex {
	int		rs = SR_BUGCHECK ;
	if (op) {
	    switch (w) {
	    case vecpstrmem_addcspath:
	        rs = vecpstr_addcspath(op) ;
	        break ;
	    case vecpstrmem_count:
	        rs = vecpstr_count(op) ;
	        break ;
	    case vecpstrmem_delall:
	        rs = vecpstr_delall(op) ;
	        break ;
	    case vecpstrmem_strsize:
	        rs = vecpstr_strsize(op) ;
	        break ;
	    case vecpstrmem_recsize:
	        rs = vecpstr_recsize(op) ;
	        break ;
	    case vecpstrmem_cksize:
	        rs = vecpstr_cksize(op) ;
	        break ;
	    case vecpstrmem_audit:
	        rs = vecpstr_audit(op) ;
	        break ;
	    case vecpstrmem_finish:
	        rs = vecpstr_finish(op) ;
	        break ;
	    } /* end switch */
	} /* end if (non-null) */
	return rs ;
} /* end method (vecpstr_co::operator) */

bool vecpstr_iter::operator == (const vecpstr_iter &oit) noex {
	return (va == oit.va) && (i == oit.i) && (ii == oit.ii) ;
}

bool vecpstr_iter::operator != (const vecpstr_iter &oit) noex {
	bool		f = false ;
	f = f || (va != oit.va) ;
	f = f || (ii != oit.ii) ;
	if (!f) {
	    f = (i < oit.i) ;
	}
	return f ;
}
/* end method (vecpstr_iter::operator) */

vecpstr_iter vecpstr_iter::operator + (int n) const noex {
	vecpstr_iter	rit(va,i,i) ;
	rit.i = ((rit.i + n) >= 0) ? (rit.i + n) : 0 ;
	return rit ;
}

vecpstr_iter &vecpstr_iter::operator += (int n) noex {
	increment(n) ;
	return *this ;
}

vecpstr_iter vecpstr_iter::operator ++ () noex { /* pre */
	increment() ;
	return *this ;
}

vecpstr_iter vecpstr_iter::operator ++ (int) noex { /* post */
	vecpstr_iter	pre(*this) ;
	increment() ;
	return pre ;
}

void vecpstr_iter::increment(int n) noex {
	if ((i + n) < 0) n = -i ;
	if (n != 0) {
	    i += n ;
	    while ((i < ii) && (va[i] == nullptr)) {
	        i += 1 ;
	    }
	}
} /* end method (vecpstr_iter::increment) */


