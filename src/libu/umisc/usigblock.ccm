/* usigblock MODULE (primary-module-interface) */
/* encoding=ISO8859-1 */
/* lang=C20 */

/* UNIX® Miscellaneous support */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-03-21, David A­D­ Morano
	This module was originally written.

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 1998,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

  	Module:
	usigblock

	Description:
	This module provides the most basic signal blocking on the
	current thread.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* ordered first to configure */
#include	<csignal>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>
#include	<ulogerror.h>

export module usigblock ;

import usigset ;			/* |usigmask(3u)| */

export {
    enum usigblockmems {
	usigblockmem_start,
	usigblockmem_finish,
	usigblockmem_overlast
    } ;
    struct usigblock ;
    struct usigblock_co {
	usigblock	*op = nullptr ;
	int		w = -1 ;
	void operator () (usigblock *p,int m) noex {
	    op = p ;
	    w = m ;
	} ;
	operator int () noex ;
	int operator () (const int * = nullptr) noex ;
    } ; /* end struct (usigblock_co) */
} /* end export (usigblock) */

export {
    struct usigblock_fl {
	uint		open:1 ;
    } ;
    struct usigblock {
    	friend		usigblock_co ;
	usigblock_co	start ;
	usigblock_co	finish ;
	usigblock_fl	fl{} ;
	sigset_t	osm ;
	usigblock() noex {
	    start	(this,usigblockmem_start) ;
	    finish	(this,usigblockmem_finish) ;
	} ;
	void dtor() noex ;
	destruct usigblock() {
	    if (fl.open) dtor() ;
	}
    private:
	int istart(cint *) noex ;
	int ifinish() noex ;
    } ; /* end class (sigblock) */
} /* end export (usigblock) */

    int usigblock::istart(cint *sigs) noex {
	int		rs = SR_FAULT ;
	    sigset_t	nsm ;
	    rs = SR_OK ;
	    if (sigs) {
	        if ((rs = usigset_empty(&nsm)) >= 0) {
	            for (int i = 0 ; (rs >= 0) && (sigs[i] > 0) ; i += 1) {
	                rs = usigset_add(&nsm,sigs[i]) ;
	            }
		}
	    } else {
	        rs = usigset_fill(&nsm) ;
	    }
	    if (rs >= 0) {
	        if ((rs = usigmask(SIG_BLOCK,&nsm,&osm)) >= 0) {
		    fl.open = true ;
		}
	    } /* end if */
	return rs ;
    } /* end method (usigblock::istart) */
    int usigblock::ifinish() noex {
	int		rs = SR_NOTOPEN ;
	if (fl.open) {
	    fl.open = false ;
	    rs = usigmask(SIG_SETMASK,&osm,nullptr) ;
	}
	return rs ;
    } /* end method (usigblock::ifinish) */
    int usigblock_co::operator () (cint *sigs) noex {
	int		rs = SR_BUGCHECK ;
	if (op) {
	    rs = op->istart(sigs) ;
	}
	return rs ;
    } /* end method (usigblock_co::operator) */
    usigblock_co::operator int () noex {
	int		rs = SR_BUGCHECK ;
	if (op) {
	    switch (w) {
	    case usigblockmem_start:
	        rs = op->istart(nullptr) ;
	        break ;
	    case usigblockmem_finish:
	        rs = op->ifinish() ;
	        break ;
	    } /* end switch */
	}
	return rs ;
    } /* end method (usigblock_co::operator) */
    void usigblock::dtor() noex {
	if (cint rs = finish ; rs < 0) {
	    ulogerror("usigblock",rs,"fini-finish") ;
	}
    } /* end method (usigblock::dtor) */


