/* filerec MODULE (primary-module-interface) */
/* charset=ISO8859-1 */
/* lang=C++20 */

/* (File-Once) implement a map container to track file device-inode values */
/* version %I% last-modified %G% */


/* revision history:

	= 2011-04-12, David A­D­ Morano
	This code was originally written.  Only the introduction
	of C++11 has allowed this (finally), due to the addition
	(in C++11) of |unordered_set(3c++)|.

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 2011,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Name:
	filerec

	Description:
	This object implements a set (an un-ordered set) with a key
	consisting of device and inode numbers.

	Symopsis:
	int filerec_start(int n = 0) noex

	Arguments:
	n		suggested starting possible number of elements

	Returns:
	>=0		ok
	<0		error (system-return)

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<sys/stat.h>		/* |dev_t| + |ino_t| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<utility>
#include	<unordered_set>
#include	<functional>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>

export module filerec ;

cint		filerec_deftablen = 100 ;

export {
    struct filerec_ent {
	cchar		*fname{} ;
	time_t		timod ;
	off_t		fsize ;
	ino_t		ino ;
	dev_t		dev ;
	mode_t		fm ;
	filerec_ent(dev_t d,ino_t i,mode_t m) noex : dev(d), ino(i), fm(m) { } ;
	size_t hashval() const noex {
	    return size_t(dev + ino) ;
	} ;
	bool equal_to(const filerec_ent &o) noex {
	    return ((dev == o.dev) && (ino == o.ino)) ;
	} ;
	void load(time_t t,off_t s) noex {
	    timod = t ;
	    fsize = s ;
	} ;
    } ; /* end struct (filerec_ent) */
    namespace std {
        template<> struct hash<filerec_ent> {
	    size_t operator() (const filerec_ent &di) const noex {
	        return di.hashval() ;
	    } ;
        } ; /* end struct-template (hash<filerec_ent>) */
        template<> struct equal_to<filerec_ent> {
	    typedef const filerec_ent	cdi ;
	    size_t operator() (cdi &lhs,cdi &rhs) const noex {
	        return ((lhs.dev == rhs.dev) && (lhs.ino == rhs.ino)) ;
	    } ;
        } ; /* end struct-template (hash<filerec_ent>) */
    } /* end namespace) */
} /* end export */

enum filerecmems {
	filerecmem_start,
	filerecmem_finish,
	filerecmem_count,
	filerecmem_overlast
} ; /* end enum (filerecmems) */

typedef std::unordered_set<filerec_ent>	filerec_base ;

export {
    struct filerec ;
    struct filerec_cur ;
    struct filerec_iter ;
    struct filerec_co {
	filerec		*op = nullptr ;
	int		w = -1 ;
	constexpr void operator () (filerec *p,int m) noex {
	    op = p ;
	    w = m ;
	} ;
	int operator () (int = 0) noex ;
	operator int () noex {
	    return operator () () ;
	} ;
    } ; /* end struct (filerec_co) */
    struct filerec {
	friend		filerec_co ;
	typedef filerec_base	stype ;
	typedef filerec_ent	key_type ;
	filerec(const filerec &) = delete ;
	filerec &operator = (const filerec &) = delete ;
	filerec_base	*setp = nullptr ;
	filerec_co	start ;
	filerec_co	finish ;
	filerec_co	count ;
	filerec() noex {
	    start	(this,filerecmem_start) ;
	    finish	(this,filerecmem_finish) ;
	    count	(this,filerecmem_count) ;
	} ; /* end ctor) */
	void dtor() noex ;
	operator int () noex ;
	destruct filerec() {
	    if (setp) dtor() ;
	} ; /* end dtor */
	int		checkin(custat *,cchar *) noex ;
	int		curbegin(filerec_cur *) noex ;
	int		curend(filerec_cur *) noex ;
	int		curenum(filerec_cur *,filerec_ent *) noex ;
	filerec_iter begin() noex ;
	filerec_iter end() noex ;
    private:
	int		istart(int) noex ;
	int		ifinish() noex ;
	int		icount() noex ;
	int		finents() noex ;
    } ; /* end class (filerec) */
    struct filerec_cur {
	filerec_base::iterator	it ;
    } ; /* end struct (filerec_cur) */
    struct filerec_iter {
	filerec_base::iterator	baseit ;
	filerec_iter() = default ;
	filerec_iter(const filerec_iter &) = default ;
	filerec_iter &operator = (const filerec_iter &) = default ;
	bool operator != (const filerec_iter &) noex ;
	bool operator == (const filerec_iter &) noex ;
	filerec_ent operator * () noex ;
	filerec_iter operator + (int) const noex ;
	filerec_iter &operator += (int) noex ;
	filerec_iter operator ++ () noex ; /* pre */
	filerec_iter operator ++ (int) noex ; /* post */
    } ; /* end struct filerec_iter) */
} /* end export */


