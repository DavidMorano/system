/* libutil MODULE */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* UNIX® kernel support subroutines */
/* version %I% last-modified %G% */


/* Copyright © 1998 David A­D­ Morano.  All rights reserved. */

module ;

#include	<envstandards.h>	/* ordered first to configure */
#include	<climits>		/* |INT_MAX| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<cstdarg>
#include	<cstring>		/* |strlen(3c)| + |strnlen(3c)| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>

export module libutil ;

export {
    constexpr inline int cstrnlen(cchar *sp,int sl = -1) noex {
    	cchar		*cp = sp ;
	while (sl && *cp++) {
	    sl -= 1 ;
	}
	return int(cp - sp) ;
    }
    constexpr inline int cstrlen(cchar *sp) noex {
    	int		len = 0 ;
	while (sp[len]) len += 1 ;
	return len ;
    }
    constexpr inline int xstrnlen(cchar *sp,int sl) noex {
    	int		len = 0 ;
	if (sl >= 0) {
    	    csize	ssize = size_t(sl) ;
	    len = intconv(strnlen(sp,ssize)) ;
	} else {
	    len = intconv(strlen(sp)) ;
	}
    	return len ;
    }
    constexpr inline int xstrlen(cchar *sp) noex {
    	return intconv(strlen(sp)) ;
    }
} /* end export */

export {
    constexpr inline int clenstr(cchar *sp,int sl = -1) noex {
    	cchar		*cp = sp ;
	while (sl && *cp++) {
	    sl -= 1 ;
	}
	return intconv(cp - sp) ;
    } /* end subroutine (clenstr) */
    constexpr inline int lenstr(cchar *sp,int sl = -1) noex {
    	int		len = -1 ;
	if (sp) {
	    if (sl >= 0) {
    	        csize	ssize = size_t(sl) ;
	        len = intconv(strnlen(sp,ssize)) ;
	    } else {
	        len = intconv(strlen(sp)) ;
	    }
	} /* end if (non-null) */
    	return len ;
    } /* end subroutine (lenstr) */
    constexpr inline int getlenstr(cchar *sp,int sl = -1) noex {
	int		len = -1 ;
	if (sp) {
	    if (sl >= 0) {
		len = sl ;
	    } else {
	        len = intconv(strlen(sp)) ;
	    }
	} /* end if (non-null) */
	return len ;
    } /* end subroutine (getlenstr) */
} /* end export */

export {
    constexpr inline int xstrspn(cchar *sp,cchar *ss) noex {
    	return intconv(strspn(sp,ss)) ;
    }
    constexpr inline int xstrcspn(cchar *sp,cchar *ss) noex {
    	return intconv(strcspn(sp,ss)) ;
    }
} /* end export */

export {
    constexpr inline char *strcopy(char *dp,cchar *sp,int sl = -1) noex {
	char	*rp ;
	if (sl >= 0) {
	    csize ssize = size_t(sl) ;
	    rp = stpncpy(dp,sp,ssize) ;
	} else {
	    rp = stpcpy(dp,sp) ;
	}
	return rp ;
    }
} /* end export */

export {
    constexpr inline char *strcpy(char *dp,cchar *ss,int n) noex {
	char	*rp ;
	if (n >= 0) {
	    rp = strncpy(dp,ss,n) ;
	} else {
	    rp = strcpy(dp,ss) ;
	}
    	return rp ;
    } /* end subroutine (strcpy) */
    constexpr inline char *stpcpy(char *dp,cchar *ss,int n) noex {
	char	*rp ;
	if (n >= 0) {
	    rp = stpncpy(dp,ss,n) ;
	} else {
	    rp = stpcpy(dp,ss) ;
	}
    	return rp ;
    } /* end subroutine (stpcpy) */
} /* end export */

export {
    constexpr inline int memclear(void *objp,int sz) noex {
    	csize	objs = size_t(sz) ;
    	memset(objp,0,objs) ;
	return sz ;
    }
    template<typename T> constexpr inline int memclear(T *op) noex {
	cint	osz = szof(T) ;
	return memclear(op,osz) ;
    }
} /* end export */

export {
    template<typename T> constexpr inline void *memcpy(T *dp,cvoid *sp) noex {
	csize	dsize = sizeof(T) ;
	return memcpy(dp,sp,dsize) ;
    }
    template<typename T>
    constexpr inline void *cmemcpy(T *dp,cvoid *sp,size_t dsize = -1) noex {
    	if (dsize > INT_MAX) dsize = sizeof(T) ;
    	return memcpy(dp,sp,dsize) ;
    }
} /* end export */

export {
    constexpr inline void *memcopy(void *dp,cvoid *sp,int sl) noex {
	caddr_t		rp = nullptr ; /* return-value */
	if (dp && sp) {
	    if (sl < 0) {
	        cchar *cp = ccharp(sp) ;
	        sl = intconv(strlen(cp)) ;
	    }
	    {
	        csize	srcsize = size_t(sl) ;
	        caddr_t	dst = caddr_t(dp) ;
	        memcpy(dp,sp,srcsize) ;
	        rp = (dst + sl) ;
	    }
	} /* end if (non-null) */
	return voidp(rp) ;
    } /* end subroutine (memcopy) */
    template<typename T>
    constexpr inline void *memcopy(T *dp,cvoid *sp,int sl = -1) noex {
    	caddr_t		rp = nullptr ;
	if (dp && sp) {
    	    if (sl < 0) sl = szof(T) ;
	    rp = caddr_t(dp) ;
	    {
		csize srcsize = size_t(sl) ;
	        memcpy(dp,sp,srcsize) ;
	        rp += sl ;
	    } /* end block */
	} /* end if (non-null) */
	return voidp(rp) ;
    } /* end subroutine (memcopy) */
    template<typename T>
    constexpr inline void *memcopyz(T *dp,int dl,cvoid *sp,int sl) noex {
    	caddr_t		rp = nullptr ;
	if (dp && sp) {
	    if (dl < 0) {
		dl = szof(T) ;
	    }
	    if (sl < 0) {
	        cchar *cp = ccharp(sp) ;
	        sl = intconv(strlen(cp)) ;
	    }
	    if (sl > dl) sl = dl ;
	    {
	        csize	srcsize = size_t(sl) ;
	        caddr_t	dst = caddr_t(dp) ;
	        memcpy(dp,sp,srcsize) ;
	        rp = (dst + sl) ;
		if (sl < dl) {
		    csize zsize = size_t(dl - sl) ;
		    memset(rp,0,zsize) ;
		}
	    } /* end block */
	} /* end if (non-null) */
	return voidp(rp) ;
    } /* end subroutine (memcopyz) */
} /* end export */

export {
    int lenstrarr(mainv a) noex {
    	int	n = -1 ; /* return-value */
	if (a) {
	    for (n = 0 ; a[n] ; n += 1) ;
	}
	return n ;
    }
} /* end export */

export {
    int loadstrs(cc **,int,...) noex ;
} /* end export */

export {
    template<typename T>
    constexpr inline T *resumelife(void *vp) noex {
    	T *rp = cast_static<T *>(vp) ;
    	return rp ;
    }
} /* end export */


