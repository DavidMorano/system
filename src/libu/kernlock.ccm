/* kernlock MODULE */
/* encoding=ISO8859-1 */
/* lang=C++20 */

/* Kernel-Lock manager */
/* version %I% last-modified %G% */


/* revision history:

	= 2000-05-14, David A­D­ Morano
	Originally written for Rightcore Network Services.

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 2000,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

  	Name:
	kernlock

	Description:
	This module provides emulated kernel-lock servies for
	am emulated kernel call facility (possibly consisting of 
	a group of related emulated kernel calls).

*******************************************************************************/

module ;

#include	<envstandards.h>	/* ordered first to configure */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<aflag.hh>
#include	<sigblocke.h>
#include	<timewatch.hh>
#include	<ptm.h>
#include	<localmisc.h>

export module kernlock ;

import usigblock ;

/* local defines */


/* imported namespaces */


/* local typedefs */


/* exported variables */


/* external subroutines */


/* local structures */

export {
    struct kernlock {
	ptm		mx ;		/* data mutex */
	aflag		fvoid ;
	aflag		finit ;
	aflag		finitdone ;
	int init() noex ;
	int fini() noex ;
	int forkbefore() noex ;
	int forkafter() noex ;
	virtual int kernbegin() noex ;
	virtual int kernen() noex ;
    private:
	void iforkbefore() noex {
	    mx.lockbegin() ;
	} ;
	void iforkafter() noex {
	    mx.lockend() ;
	} ;
	destruct kernlock () {
            if (cint rs = fini() ; rs < 0) {
                ulogerror("kernlock",rs,"dtor-fini") ;
            }
	} ;
    } ; /* end struct (kernlock) */
} /* end namespace */


/* forward references */


/* local variables */


/* exported variables */


/* exported subroutines */

int kernlockget() noex {
	int		rs ;
	int		rs1 ;
	int		cmask = 0 ;
	if (sigblocker b ; (rs = b.start) >= 0) {
	    {
		rs = kernlock_data.get() ;
		cmask = rs ;
	    }
	    rs1 = b.finish ;
	    if (rs >= 0) rs = rs1 ;
	} /* end if (sigblocker) */
	return (rs >= 0) ? cmask : rs ;
}
/* end subroutine (kernlockget) */

int kernlockset(mode_t cmask) noex {
	int		rs ;
	int		rs1 ;
	int		omask = 0 ;
	if (sigblocker b ; (rs = b.start) >= 0) {
	    {
		rs = kernlock_data.setmode(cmask) ;
		omask = rs ;
	    }
	    rs1 = b.finish ;
	    if (rs >= 0) rs = rs1 ;
	} /* end if (sigblocker) */
	return (rs >= 0) ? omask : rs ;
}
/* end subroutine (kernlockset) */


/* local subroutines */

int kernlocker::init() noex {
	int		rs = SR_NXIO ;
	int		f = false ;
	if (! fvoid) {
	    cint	to = utimeout[uto_busy] ;
	    rs = SR_OK ;
	    if (! finit.testandset) {
	        if ((rs = mx.create) >= 0) {
	            void_f	b = kernlock_atforkbefore ;
	            void_f	a = kernlock_atforkafter ;
	            if ((rs = uc_atfork(b,a,a)) >= 0) {
			void_f	e = kernlock_exit ;
	                if ((rs = uc_atexit(e)) >= 0) {
	    	            finitdone = true ;
		            f = true ;
		        }
		        if (rs < 0) {
		            uc_atforkexpunge(b,a,a) ;
			}
	            } /* end if (uc_atfork) */
	 	    if (rs < 0) {
		        mx.destroy() ;
		    }
	        } /* end if (ptm_create) */
	        if (rs < 0) {
	            finit = false ;
		}
            } else if (! finitdone) { 
                timewatch       tw(to) ;
                auto lamb = [this] () -> int {
                    int         rs = SR_OK ;
                    if (!finit) {
                        rs = SR_LOCKLOST ;              /* <- failure */
                    } else if (finitdone) {
                        rs = 1 ;                        /* <- OK ready */
                    }                       
                    return rs ;
                } ; /* end lambda (lamb) */ 
                rs = tw(lamb) ;         /* <- time-watching occurs in there */
	    } /* end if */
	} /* end if (not-voided) */
	return (rs >= 0) ? f : rs ;
}
/* end subroutine (kernlock_init) */

int kernlocker::fini() noex {
	int		rs = SR_OK ;
	int		rs1 ;
	if (finitdone && (! fvoid.testandset)) {
	    {
	        void_f	b = kernlock_atforkbefore ;
	        void_f	a = kernlock_atforkafter ;
	        rs1 = uc_atforkexpunge(b,a,a) ;
		if (rs >= 0) rs = rs1 ;
	    }
	    {
	        rs1 = mx.destroy ;
		if (rs >= 0) rs = rs1 ;
	    }
	    finit = false ;
	    finitdone = false ;
	} /* end if (atexit registered) */
	return rs ;
}
/* end method (kernlocker::fini) */

int kernlocker::get() noex {
	int		rs ;
	int		rs1 ;
	int		cmask = 0 ;
	if ((rs = init()) >= 0) {
	    if ((rs = uc_forklockbegin(-1)) >= 0) { /* multi */
	        if ((rs = mx.lockbegin) >= 0) { /* single */
		    {
			cmask = kernlock(0) ; /* in case of race! */
			kernlock(cmask) ;
		    }
	            rs1 = mx.lockend ;
		    if (rs >= 0) rs = rs1 ;
	        } /* end if (mutex) */
	        rs1 = uc_forklockend() ;
		if (rs >= 0) rs = rs1 ;
	    } /* end if (forklock) */
	} /* end if (init) */
	cmask &= INT_MAX ;
	return (rs >= 0) ? cmask : rs ;
}
/* end method (kernlocker::get) */

int kernlocker::setmode(mode_t cmask) noex {
	int		rs ;
	int		rs1 ;
	int		omask = 0 ;
	if ((rs = init()) >= 0) {
	    if ((rs = uc_forklockbegin(-1)) >= 0) { /* multi */
	        if ((rs = mx.lockbegin) >= 0) { /* single */
		    {
			omask = kernlock(cmask) ;
		    }
	            rs1 = mx.lockend ;
	            if (rs >= 0) rs = rs1 ;
	        } /* end if (mutex) */
	        rs1 = uc_forklockend() ;
	        if (rs >= 0) rs = rs1 ;
	    } /* end if (forklock) */
	} /* end if (init) */
	omask &= INT_MAX ;
	return (rs >= 0) ? omask : rs ;
}
/* end subroutine (kernlocker::set) */


