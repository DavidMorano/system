/* filemagic MODULE (primary-module-interface) */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* this object helps manage the magic information in (DB) files */
/* version %I% last-modified %G% */


/* revision history:

	= 2004-02-17, David A­D­ Morano
	This code module was inspired from the mail-message-id
	database (which is used to eliminate repeated mail messages).

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 2004,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

  	Object:
	filemagic

	Description:
	This module contains an object (FILEMAGIC) that helps manage
	the magic information in (constant) data-base (DB) files.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* must be ordered fist to configure */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<usystem.h>
#include	<serialbuf.h>
#include	<mkmagic.h>
#include	<localmisc.h>

export module filemagic ;

import libutil ;

/* local defines */


/* imported namespaces */


/* local typedefs */


/* external subroutines */


/* external variables */


/* exported structures */

cint		magsz = 16 ;		/* magic-string size (including NL) */

export {
    struct filemagic {
	char		magic[magsz] ;
	uchar		vetu[4] ;
	static cint	bufsz ;
	int rd(char *,int = -1) noex ;
	int wr(cchar *,int) noex ;
	int load(cchar *,int,uchar = 0,uchar = 0,uchar = 0,uchar = 0) noex ;
    } ; /* end struct filemagic) */
 } /* end export */


/* forward references */


/* local variables */


/* exported variables */

cint filemagic::bufsz = (magsz + szof(uint)) ;


/* exported subroutines */

int filemagic::rd(char *rbuf,int rlen) noex {
    	int		rs = SR_FAULT ;
	int		len = 0 ;
	if (rbuf) {
	    rs = SR_OVERFLOW ;
	    if ((rlen < 0) || (rlen >= bufsz)) {
	        caddr_t bp = rbuf ;
		rs = SR_OK ;
	        bp = caddr_t(memcopy(bp,magic,magsz)) ;
	        bp = caddr_t(memcopy(bp,vetu,4)) ;
	        len = intconv(bp - rbuf) ;
	    }
	} /* end if (non-null) */
	return (rs >= 0) ? len : rs ;
}
/* end method (filemagic:rd) */

int filemagic::wr(cchar *fbuf,int flen) noex {
    	int		rs = SR_FAULT ;
	if (fbuf) {
	    rs = SR_INVALID ;
	    if (fbuf[0] && ((flen < 0) || (flen >= bufsz))) {
		ccharp	bp = fbuf ;
		bp = charp(memcopy(magic,bp,magsz)) ;
		memcopy(vetu,bp,szof(uint)) ;
	        rs = SR_OK ;
	    } /* end if (valid) */
	} /* end if (non-null) */
	return rs ;
}
/* end method (filemagic:wr) */

int filemagic::load(cc *mstr,int mlen,uchar v,uchar e,uchar t,uchar u) noex {
    	int		rs = SR_FAULT ;
	int		len = 0 ;
	if (mstr) {
	    rs = SR_INVALID ;
	    if (mstr[0]) {
	        if ((rs = mkmagic(magic,magsz,mstr,mlen)) >= 0) {
		    len = xstrnlen(mstr,mlen) ;
	            vetu[0] = v ;
	            vetu[1] = e ;
	            vetu[2] = t ;
	            vetu[3] = u ;
	        } /* end if (mkmagic) */
	    } /* end if (valid) */
	} /* end if (non-null) */
	return (rs >= 0) ? len : rs ;
}
/* end method (filemagic:load) */

#ifdef	COMMENT
static int filemagic(char *buf,int f_read,FM *mp) noex {
	int		rs = 20 ;
	char		*bp = buf ;
	char		*cp ;

	if (buf == nullptr) return SR_BADFMT ;

	if (f_read) {

	    bp[15] = '\0' ;
	    strncpy(mp->magic,bp,15) ;

	    if ((cp = strchr(mp->magic,'\n')) != nullptr) {
	        *cp = '\0' ;
	    }

	    bp += 16 ;
	    memcpy(mp->vetu,bp,4) ;

	} else {

	    bp = strwcpy(bp,mp->magic,14) ;

	    *bp++ = '\n' ;
	    memset(bp,0,(16 - (bp - buf))) ;

	    bp = buf + 16 ;
	    memcpy(bp,mp->vetu,4) ;

	} /* end if */

	return rs ;
}
/* end subroutine (filemagic) */
#endif /* COMMENT */


