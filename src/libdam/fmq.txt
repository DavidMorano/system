int fmq_open(fmq *op,cchar *fname,int of,mode_t operm,int bufsize) noex {
	struct ustat	sb ;
	time_t		daytime = time(NULL) ;
	int		rs ;
	int		amode ;
	int		f_create = FALSE ;

#if	CF_SAFE
	if (op == NULL) return SR_FAULT ;
#endif /* CF_SAFE */

	if (fname == NULL) return SR_FAULT ;

	if (fname[0] == '\0') return SR_INVALID ;

	if (bufsize < FMQ_BUFSIZE)
	    bufsize = FMQ_BUFSIZE ;

	memset(op,0,sizeof(FMQ)) ;
	op->magic = 0 ;
	op->fname = NULL ;

#if	CF_ALWAYSCREATE
	oflags |= O_CREAT ;
#endif

	oflags = (oflags & (~ O_TRUNC)) ;

	op->f.create = (oflags & O_CREAT) ? TRUE : FALSE ;
	op->f.ndelay = (oflags & O_NDELAY) ? TRUE : FALSE ;
	op->f.nonblock = (oflags & O_NONBLOCK) ? TRUE : FALSE ;

	oflags = (oflags & (~ (O_NDELAY | O_NONBLOCK))) ;

	op->oflags = oflags ;
	op->operm = operm ;

	{
	    const char	*cp ;
	    rs = uc_mallocstrw(fname,-1,&cp) ;
	    if (rs >= 0) op->fname = cp ;
	}
	if (rs < 0) goto bad0 ;

/* initialize the buffer structure */

	rs = fmq_bufinit(op) ;
	if (rs < 0)
	    goto bad1 ;

/* try to open the file */

	oflags = (oflags & (~ O_CREAT)) ;
	rs = u_open(op->fname,oflags,operm) ;

	if ((rs < 0) && (op->oflags & O_CREAT)) {

	    f_create = TRUE ;
	    oflags = op->oflags ;
	    rs = u_open(op->fname,oflags,operm) ;

	} /* end if (creating file) */

	op->fd = rs ;
	if (rs < 0)
	    goto bad2 ;

	amode = (operm & O_ACCMODE) ;
	op->f.writable = ((amode == O_WRONLY) || (amode == O_RDWR)) ;

	op->opentime = daytime ;
	op->accesstime = daytime ;
	rs = u_fstat(op->fd,&sb) ;
	if (rs < 0)
	    goto bad3 ;

	op->mtime = sb.st_mtime ;
	op->filesize = sb.st_size ;
	op->pagesize = getpagesize() ;

/* local or remote */

	rs = isfsremote(op->fd) ;
	op->f.remote = (rs > 0) ;
	if (rs < 0)
	    goto bad3 ;

/* determine some operational parameters (size of buffer space) */

	op->bufsize = uceil(bufsize,sizeof(int)) ;

/* setup for disabling signals */

	uc_sigsetfill(&op->sigmask) ;

/* header processing */

	rs = fmq_fileinit(op,daytime) ;

	if ((rs < 0) && (rs != SR_AGAIN))
	    goto bad3 ;

	if ((rs == SR_AGAIN) && (! op->f.create))
	    rs = SR_OK ;

/* out of here */

	op->magic = FMQ_MAGIC ;

ret0:
	return (rs >= 0) ? f_create : rs ;

/* bad things */
bad4:
bad3:
	u_close(op->fd) ;

bad2:
	fmq_buffree(op) ;

bad1:
	if (op->fname != NULL)
	    uc_free(op->fname) ;

bad0:
	goto ret0 ;
}
/* end subroutine (fmq_open) */

