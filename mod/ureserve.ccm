/* ureserve MODULE (primary-module-interface) */
/* encoding=ISO8859-1 */
/* lang=C20 */

/* reserved interfaces */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-03-21, David A­D­ Morano
	This module was originally written.

	= 2020-05-07, David A-D- Morano
	I converted this (formerly a header-only file) to a module.

*/

/* Copyright © 1998,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

  	Module:
	ureserve

	Description:
	This module provides miscellaneous UNIX® or other
	common (library oriented) subroutines.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* ordered first to configure */
#include	<climits>		/* |UCHAR_MAX| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<vector>
#include	<string>
#include	<iostream>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>
#include	<localmisc.h>

export module ureserve ;

using std::vector ;			/* type */
using std::string ;			/* type */
using std::cerr ;			/* variable */

export {
    bool isoneof(cint *,int) noex ;
    inline bool isOneOf(cint *rsa,int rs) noex {
	    return isoneof(rsa,rs) ;
    }
} /* end export */

export {
    bool isNotPresent(int) noex ;
    bool isNotAccess(int) noex ;
    bool isNotValid(int) noex ;
    bool isNotLib(int) noex ;
    bool isNotTerm(int) noex ;
    bool isNotSupport(int) noex ;
    inline bool isInvalid(int rs) noex {
	return isNotValid(rs) ;
    }
} /* end export */

export {
    bool char_iswhite(int) noex ;
    bool char_islc(int) noex ;
    bool char_isuc(int) noex ;
    inline bool char_isspacetab(int ch) noex {
	return (ch == ' ') || (ch == '\t') ;
    }
    inline bool char_isdig(int ch) noex {
	return ((ch >= '0') && (ch <= '9')) ;
    }
} /* end export */

export {
    uchar	char_tolc(int) noex ;
    uchar	char_touc(int) noex ;
    uchar	char_tofc(int) noex ;
    short	char_dictorder(int) noex ;
    int		char_toval(int) noex ;
} /* end export */

export {
    bool	iswhite(int) noex ;
    bool	isalnumlatin(int) noex ;
    bool	isalphalatin(int) noex ;
    bool	isdict(int) noex ;
    bool	ishexlatin(int) noex ;
    bool	islowerlatin(int) noex ;
    bool	isupperlatin(int) noex ;
    bool	isprintbad(int) noex ;
    bool	isprintlatin(int) noex ;
    bool	isprintterm(int) noex ;
    bool	iscmdstart(int) noex ;
    bool	ishdrkey(int) noex ;
    inline bool	isdigitlatin(int ch) noex {
	    return (ch >= '0') && (ch <= '9') ;
    }
    inline bool	isdeclatin(int ch) noex {
    	    return isdigitlatin(ch) ;
    }
    inline bool	isoctlatin(int ch) noex {
	    return (ch >= '0') && (ch <= '7') ;
    }
    inline bool	isnumlatin(int ch) noex {
    	    return ishexlatin(ch) || (ch == '\\') || (ch == 'x') ;
    }
    inline bool	isnumsign(int ch) noex {
	    return ((ch == '+') || (ch == '-')) ;
    }
    inline bool	iseol(int ch) noex {
	    return (ch == '\n') || (ch == '\r') ;
    }
    inline bool	iszero(int ch) noex {
	    return (ch == '0') ;
    }
    inline bool	isplusminus(int ch) noex {
	    return (ch == '+') || (ch == '-') ;
    }
    inline bool	isabbr(int ch) noex {
	    ch &= UCHAR_MAX ;
	    return (ch == '.') || (ch == ('­' & UCHAR_MAX)) || (ch == '-') ;
    }
    inline bool	isspacetab(int ch) noex {
	    return (ch == ' ') || (ch == '\t') ;
    }
    inline bool	isAbbr(int ch) noex {
    	    return isabbr(ch) ;
    }
} /* end export */

enum vecstrmems {
    	vecstrmem_start,
    	vecstrmem_finish,
    	vecstrmem_count,
    	vecstrmem_delall,
    	vecstrmem_overlast
} ; /* end enum (vecstrmems) */

struct vecstr_fl {
    	uint		open:1 ;
} ;

export {
    struct vecstr ;
    struct vecstr_co {
	vecstr		*op = nullptr ;
	int		w = -1 ;
	void operator () (vecstr *p,int m) noex {
	    op = p ;
	    w = m ;
	} ;
	int operator () (int = -1) noex ;
	operator int () noex {
	    return operator () () ;
	} ;
    } ; /* end struct (vecstr_co) */
    struct vecstr_cur ;
    struct vecstr : vector<string> {
	friend		vecstr_co ;
	vecstr_co	start ;
	vecstr_co	finish;
	vecstr_co	count ;
	vecstr_co	delall ;
	vecstr_fl	fl{} ;
	vecstr &operator = (const vecstr &) = delete ;
	vecstr(const vecstr &) = delete ;
	vecstr() noex {
	    cerr << "vecstr: ctor" << eol ;
	    start(this,vecstrmem_start) ;
	    finish(this,vecstrmem_finish) ;
	    count(this,vecstrmem_count) ;
	    delall(this,vecstrmem_delall) ;
	} ; /* end ctor */
	int add(cchar *,int = -1) noex ;
	int adduniq(cchar *,int = -1) noex ;
	int find(cchar *,int = -1) noex ;
	int del(int) noex ;
	int curbegin(vecstr_cur *) noex ;
	int curend(vecstr_cur *) noex ;
	int curenum(vecstr_cur *,cchar **) noex ;
	operator int () noex ;
	destruct vecstr() {
	    if (fl.open) dtor() ;
	} ;
    private:
	int istart(int = 0) noex ;
	int ifinish() noex ;
	int idelall() noex ;
	int iadd(cchar *,int = -1) noex ;
	int idel(int) noex ;
	void dtor() noex ;
    } ; /* end struct (vecstr) */
    struct vecstr_cur {
	vecstr::iterator	it ;
    } ; /* end struct (vestr_cur) */
} /* end export */

export {
    struct utest {
	utest() noex {
	    cerr << "utest-ctor" << eol ;
	} ;
	int start() noex {
	    cerr << "utest-start" << eol ;
	    return 0 ;
	} ;
	void dtor() noex {
	    cerr << "utest-dtor" << eol ;
	} ;
	destruct utest() {
	    cerr << "utest-destruct" << eol ;
	    dtor() ;
	} ;
    } ; /* end struct (utest) */
} /* end export */


