/* xxtostr MODULE (primary-module-interface) */
/* charset=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* subroutines to convert an integer to a c-string */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-03-01, David A­D­ Morano
	This code was originally written.

	= 2023-07-11, David A-D- Morano
	I changed this code from a regular source C++ file into
	a C++20 module.  I will track how successful this change
	turns out to be.

*/

/* Copyright © 1998,2023 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Group:
	{xx}tostr

	Names:
	uxxtostr
	sxxtostr

	Description:
	These subroutine templates convert an integer (signed or
	unsigned of various sized types) into a c-string digit
	representation that is placed into the caller supplied
	buffer (of specified length).  A numerical base is also
	supplied by the caller and must be between 2 and 64.  Only
	upper-case hexadecimal digit charactes are supported
	(characters '0' through '9' and 'A' through 'Z').  Convert
	your hexadecimal digit c-string to upper case before
	conversion.  The upport part of numerical base higher than
	36 are represented by the lower-case alphabetic characters
	('a' through 'z').  Only types of |int| (32-bits), |long|
	(64-bits), and |longlong| (128-bits) and their unsigned
	cousins and aliases are supported.

	Synopsis:
	template<typename UT,typename ST>
	char *uxxtostr(char **endp,int b,ST v) noex
	char *sxxtostr(char **endp,int b,ST v) noex

	Arguments:
	endp		pointer to one past the end of the supplied buffer
	b		number base
	v		integer value to be converted

	Returns:
	>=0		length of buffer used by the conversion
	<0		error in the conversion

	Group:
    	itostr
    	ltostr
    	lltostr
    	uitostr
    	ultostr
    	ulltostr

	Description:
	These subroutines (w/ C-language linkage) are supplied for
	base-10 operations.  The same integer types as above are
	supported.  As might be notes (by some astute observers)
	subroutines with these same names are supplied on (pretty
	much now historical) System V Release 4 based operating
	systems (an example of which was Solaris® and the more
	modern Illumos®).

	Synopsis:
    	char *itostr(int v,char *endp) noex
    	char *ltostr(long v,char *endp) noex
    	char *lltostr(longlong v,char *endp) noex
    	char *uitostr(uint uv,char *endp) noex
    	char *ultostr(ulong uv,char *endp) noex
    	char *ulltostr(ulonglong uv,char *endp) noex

	Arguments:
	v	signed value to convert
	uv	unsigned value to convert
	endp	the ending pointer position of a supplied buffer

	Notes:
	As it stands now, these subroutines do not perform any funny
	business in trying to make this process faster!  These
	subroutines are, therefore, probably the slowest such
	conversions routinely available.  To really move (execute)
	quickly through the division-related aspects of the required
	algorithm, one would have to use assembly language where
	both the quotient and the reminder of a division are produced
	simultaneously (since each are needed to continue).  This,
	of course, assumes that the underlying machine architecture
	has such instructions.  But short of assembly (and and the
	required machine instructions) this present implemtnation
	is adequate.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<cerrno>		/* |errno| */
#include	<climits>		/* |LONG_MAX| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstdlib>
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>		/* |MAXBASE| */
#include	<usysrets.h>
#include	<stdintx.h>		/* extended integers */
#include	<syswords.hh>		/* |sysword(3u)| */
#include	<localmisc.h>		/* ?? not-needed ?? */

#pragma		GCC dependency	"mod/digtab.ccm"

export module xxtostr ;

import digtab ;				/* |getdig(3u)| */

/* local defines */


/* external subroutines */


/* external variables */


/* local structures */


/* forward references */

constexpr cint		xxtostr_maxbase = MAXBASE ; /* standard value */

export {
    template<typename UT>
    constexpr inline int uxxtostr(char *endp,int b,UT v) noex {
	uint		ub = uint(b) ;
	int		rs = SR_FAULT ;
	char		*rp = endp ;
	if (endp) {
	    rs = SR_NOTSUP ;
	    *rp = '\0' ;
	    if ((b >= 2) && (b <= xxtostr_maxbase)) {
	        if (v != 0) {
                    int		di ;
	            if_constexpr (szof(UT) > szof(ulong)) {
	                const UT	vmask(~ LONG_MAX) ;
		        UT		utnv ;
	                while ((v & vmask) != 0L) {
	                    utnv = v / ub ;
                            di = int(v - (utnv * ub)) ;
                            *--rp = getdig(di) ;
	                    v = utnv ;
	                } /* end while (slower) */
	                {
		            ulong	lv = ulong(v) ;
		            ulong	nv ;
		            while (lv != 0) {
	                        nv = lv / ub ;
                                di = int(lv - (nv * ub)) ;
                                *--rp = getdig(di) ;
	                        lv = nv ;
		            } /* end while */
		            v = lv ;
	                } /* end block (faster) */
	            } else {
		        UT		nv ;
	                while (v != 0) {
	                    nv = v / ub ;
                            di = int(v - (nv * ub)) ;
                            *--rp = getdig(di) ;
	                    v = nv ;
	                } /* end while (regular) */
		    } /* end if-constexpr (size-of-operand) */
	            rs = SR_OK ;
	        } else {
	            rs = SR_OK ;
	            *--rp = '0' ;
	        } /* end if */
	    } /* end if (base supported) */
	} /* end if (non-null) */
	return (rs >= 0) ? int(endp - rp) : rs ;
    } /* end subroutine-template (uxxtostr) */
} /* end export */

export {
    template<typename UT,typename ST>
    constexpr inline int sxxtostr(char *endp,int b,ST v) noex {
	UT		ulv = (UT) v ;
	int		rs = SR_FAULT ;
	char		*rp = nullptr ;
	if (v < 0) ulv = (- ulv) ;
	if (endp) {
	    if ((rs = uxxtostr(endp,b,ulv)) >= 0) {
		rp = (endp - rs) ;
	        if (v < 0) *--rp = '-' ;
	    }
	}
	return (rs >= 0) ? int(endp - rp) : rs ;
    } /* end subroutine (sxxtostr) */
} /* end export */


/* local variables */

constexpr int		b = 10 ;


/* exported variables */


/* exported subroutines */

export {
    template<typename UT,typename T> 
    constexpr inline char *stostr(T v,char *endp) noex {
	int		rs ;
	char		*rp = nullptr ;
	if ((rs = sxxtostr<UT>(endp,b,v)) >= 0) {
	    rp = (endp - rs) ;
	} else {
	    errno = (- rs) ;
	}
	return (rs >= 0) ? rp : nullptr ;
    }
    template<typename UT> 
    constexpr inline char *utostr(UT uv,char *endp) noex {
	char		*rp = nullptr ;
	int		rs ;
	if ((rs = uxxtostr(endp,b,uv)) >= 0) {
	    rp = (endp - rs) ;
	} else {
	    errno = (- rs) ;
	}
	return (rs >= 0) ? rp : nullptr ;
    }
} /* end export */

export extern "C" {
    char *itostr(int v,char *endp) noex {
	return stostr<uint>(v,endp) ;
    }
    char *ltostr(long v,char *endp) noex {
	return stostr<ulong>(v,endp) ;
    }
    char *lltostr(longlong v,char *endp) noex {
	return stostr<ulonglong>(v,endp) ;
    }
    char *uitostr(uint uv,char *endp) noex {
	return utostr(uv,endp) ;
    }
    char *ultostr(ulong uv,char *endp) noex {
	return utostr(uv,endp) ;
    }
    char *ulltostr(ulonglong uv,char *endp) noex {
	return utostr(uv,endp) ;
    }
} /* end export (extern) */


