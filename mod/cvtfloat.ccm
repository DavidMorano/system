/* cvtfloat MODULE (primary-module-interface) */
/* encoding=ISO8859-1 */
/* lang=C++20 (conformance reviewed) */

/* convert a float (|double| + |longdouble|) into a figit-string */
/* version %I% last-modified %G% */


/* revision history:

	= 1998-03-01, David A­D­ Morano
	This subroutine was written to get a portable float-to-string
	function when on a UNIX® platform.

	= 2020-07-12, David A­D­ Morano
	I converted this code to be a (new) C++20 "module."

*/

/* Copyright © 1998,2020 David A­D­ Morano.  All rights reserved. */

/*******************************************************************************

	Name:
	cvtfloat

	Description:
	This subroutine converts a float value of type |double| or
	|longdouble| into a digit-string in a way desired by a
	|printf(3c)|-like function.

	Synopsis:
	template<typename T>
	int cvtfloat(char *rbuf,int rlen,int fc,int fl,int w,int p,T dv) noex

	Arguments:
	rbuf		result buffer pointer
	rlen		result buffer length
	fc		format-code, one of: e, f, g, G, a A, E, F, G
	fl		fill-flag
	w		field width
	p		digit precision
	dv		floating value to convert (|double| or |longdouble|)

	Returns:
	-		length of result characters

	Notes:
	1. Of course this is a quickie hack for handling floating-point.
	I do not use any of the older custom conversion subroutines that
	I used to use for coverting from floating types to digig-strings.

*******************************************************************************/

module ;

#include	<envstandards.h>	/* MUST be first to configure */
#include	<climits>		/* |CHAR_BIT| */
#include	<cstddef>		/* |nullptr_t| */
#include	<cstring>		/* |strchr(3c)| + |stpcpy(3c)| */
#include	<clanguage.h>
#include	<utypedefs.h>
#include	<utypealiases.h>
#include	<usysdefs.h>
#include	<usysrets.h>
#include	<stdintx.h>
#include	<libutil.hh>
#include	<snx.h>			/* |snwprintf(3uc)| */
#include	<xxtostr.h>		/* |itostr(3u)| */
#include	<localmisc.h>

export module cvtfloat ;

import fmtflag ;

constexpr cint		wmax = 256 ;
constexpr cint		pmax = 256 ;
constexpr cint		fmtlen = 30 ;
constexpr cint		dlen = DECBUFLEN ;
constexpr cchar		codes[] = "aefgAEFG" ;

int ctstr(char *dbuf,int dlen,char *fp,int rl,int v) noex {
    	cnullptr	np{} ;
    	int		rs = SR_OK ;
	int		dl = 0 ; /* return-value */
	if (cc *dp ; (dp = itostr(v,(dbuf + dlen))) != np) {
	    dl = intconv((dbuf + dlen) - dp) ;
	    if (dl > rl) {
		fp = stpcpy(fp,dp) ;
	    } else {
		rs = SR_OVERFLOW ;
	    }
	}
	return (rs >= 0) ? dl : rs ;
} /* end subroutine (ctstr) */

int mkflags(char *fbuf,int flen,int fg) noex {
    	fmtflag		ff(fg) ;
    	int		rs = SR_OK ;
	int		fl = 0 ; /* return-value */
	char		*fp = fbuf ;
	for (int i = 0 ; i < fmtflag_overlast ; i += 1) {
	    if (ff[i]) {
	        int	ch = 0 ;
	        switch (i) {
	        case fmtflag_alternate:
		    ch = '#' ;
		    break ;
	        case fmtflag_zerofill:
		    ch = '0' ;
		    break ;
	        case fmtflag_plus:
		    ch = '+' ;
		    break ;
	        case fmtflag_left:
		    ch = '-' ;
		    break ;
	        case fmtflag_space:
		    ch = ' ' ;
		    break ;
	        case fmtflag_thousands:
		    ch = '\'' ;
		    break ;
	        } /* end switch */
	        if (ch) {
		    *fp++ = char(ch) ;
	        }
	    } /* end if (had flag) */
	} /* end for */
	fl = intconv(fp - fbuf) ;
	return (rs >= 0) ? fl : rs ;
} /* end subroutine (mkflags) */

int mkfmt(char *fbuf,int flen,int fc,int fg,int w,int p,int sz) noex {
    	int		rs ;
	int		fl = 0 ; /* return-value */
	char		*fp = fbuf ;
	{
	    *fp++ = '%' ;
	    fl += 1 ;
	}
	if ((rs = mkflags(fp,(flen-fl),fg)) >= 0) {
	    fp += rs ;
	    fl += rs ;
	    {
	        char	dbuf[dlen + 1] = {} ;
	        cint	alen = (flen - 10) ;
	        if ((rs >= 0) && (w >= 0)) {
		    if ((rs = ctstr(dbuf,dlen,fp,(alen -fl),w)) >= 0) {
		        fp += rs ;
		        fl -= rs ;
		    }
	        } /* end if (width) */
	        if ((rs >= 0) && (p >= 0)) {
		    *fp++ = '.' ;
		    fl += 1 ;
		    if ((rs = ctstr(dbuf,dlen,fp,(alen -fl),p)) >= 0) {
		        fp += rs ;
		        fl -= rs ;
		    }
	        } /* end if (precision) */
	        *fp = '\0' ;
	    } /* end block */
	    if (rs >= 0) {
	        if (sz == szof(longdouble)) {
	            *fp++ = 'l' ;
	            fl += 1 ;
	        }
	    } /* end block */
	    if (rs >= 0) {
	        *fp++ = char(fc) ;
	        fl += 1 ;
	    }
	} /* end if (mkflags) */
	*fp = '\0' ;
	return (rs >= 0) ? fl : rs ;
} /* end subroutine (mkfmt) */

template<typename T> struct floater {
	int	fc ;
	int	fl ;
	int	w ;
	int	p ;
    	T	dv ;
	floater(int afc,int af,int aw,int ap,T av) noex {
	    fc = afc ;
	    fl = af ;
	    w = aw ;
	    p = ap ;
	    dv = av ;
	} ; /* end ctor */
	int operator () (char *,int) noex ;
} ; /* end struct (floater) */

template<typename T> int floater<T>::operator () (char *rb,int rl) noex {
    	int		rs ;
	char		fmtbuf[fmtlen+1] ;
	if ((rs = mkfmt(fmtbuf,fmtlen,fc,fl,w,p,szof(dv))) >= 0) {
	    rs = snwprintf(rb,rl,fmtbuf,dv) ;
	} /* end if (mkfmt) */
	return rs ;
} /* end method (floater::operator) */

export {
    template<typename T>
    int cvtfloat(char *rbuf,int rlen,int fc,int fl,int wi,int pr,T dv) noex {
	int		rs = SR_FAULT ;
	if (rbuf) {
	    rs = SR_INVALID ;
	    if ((rlen > 0) && strchr(codes,fc)) {
		rs = SR_TOOBIG ;
		if ((wi <= wmax) && (pr <= pmax)) {
		    floater fo(fc,fl,wi,pr,dv) ;
		    rs = fo(rbuf,rlen) ;
		}
	    } /* end if (valid) */
	} /* end if (non-null) */
	return rs ;
    } /* end subroutine (cvtfloat) */
} /* end export */


